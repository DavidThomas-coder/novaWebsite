"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var react = require("react"), rxjs = require("rxjs"), operators = require("rxjs/operators"), observableCallback = require("observable-callback"), useEffectEvent = require("use-effect-event");
function getValue(value) {
  return typeof value == "function" ? value() : value;
}
const cache = /* @__PURE__ */ new WeakMap();
function useObservable(observable, initialValue) {
  const initialValueRef = react.useRef(getValue(initialValue));
  react.useEffect(() => {
    initialValueRef.current = getValue(initialValue);
  }, [initialValue]);
  const store = react.useMemo(() => {
    if (!cache.has(observable)) {
      const entry = {
        snapshot: initialValueRef.current
      };
      entry.observable = observable.pipe(
        operators.map((value) => ({ snapshot: value, error: void 0 })),
        rxjs.catchError((error) => rxjs.of({ snapshot: void 0, error })),
        operators.tap(({ snapshot, error }) => {
          entry.snapshot = snapshot, entry.error = error;
        }),
        // Note: any value or error emitted by the provided observable will be mapped to the cache entry's mutable state
        // and the observable is thereafter only used as a notifier to call `onStoreChange`, hence the `void` return type.
        operators.map((value) => {
        }),
        // Ensure that the cache entry is deleted when the observable completes or errors.
        rxjs.finalize(() => cache.delete(observable)),
        rxjs.share()
      ), entry.subscription = entry.observable.subscribe(), cache.set(observable, entry);
    }
    const instance = cache.get(observable);
    return instance.subscription.closed && (instance.subscription = instance.observable.subscribe()), {
      subscribe: (onStoreChange) => {
        const subscription = instance.observable.subscribe(onStoreChange);
        return instance.subscription.unsubscribe(), () => {
          subscription.unsubscribe();
        };
      },
      getSnapshot: () => {
        if (instance.error)
          throw instance.error;
        return instance.snapshot;
      }
    };
  }, [observable]);
  return react.useSyncExternalStore(
    store.subscribe,
    store.getSnapshot,
    typeof initialValueRef.current > "u" ? void 0 : () => initialValueRef.current
  );
}
function useObservableEvent(handleEvent) {
  const [[calls$, call]] = react.useState(() => observableCallback.observableCallback()), onEvent = useEffectEvent.useEffectEvent((observable) => handleEvent(observable));
  return react.useEffect(() => {
    const subscription = calls$.pipe((observable) => onEvent(observable)).subscribe();
    return () => subscription.unsubscribe();
  }, [calls$, onEvent]), call;
}
exports.useObservable = useObservable;
exports.useObservableEvent = useObservableEvent;
//# sourceMappingURL=index.cjs.map
