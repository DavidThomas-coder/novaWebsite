import { useRef, useEffect, useMemo, useSyncExternalStore, useState } from "react";
import { catchError, of, finalize, share } from "rxjs";
import { map, tap } from "rxjs/operators";
import { observableCallback } from "observable-callback";
import { useEffectEvent } from "use-effect-event";
function getValue(value) {
  return typeof value == "function" ? value() : value;
}
const cache = /* @__PURE__ */ new WeakMap();
function useObservable(observable, initialValue) {
  const initialValueRef = useRef(getValue(initialValue));
  useEffect(() => {
    initialValueRef.current = getValue(initialValue);
  }, [initialValue]);
  const store = useMemo(() => {
    if (!cache.has(observable)) {
      const entry = {
        snapshot: initialValueRef.current
      };
      entry.observable = observable.pipe(
        map((value) => ({ snapshot: value, error: void 0 })),
        catchError((error) => of({ snapshot: void 0, error })),
        tap(({ snapshot, error }) => {
          entry.snapshot = snapshot, entry.error = error;
        }),
        // Note: any value or error emitted by the provided observable will be mapped to the cache entry's mutable state
        // and the observable is thereafter only used as a notifier to call `onStoreChange`, hence the `void` return type.
        map((value) => {
        }),
        // Ensure that the cache entry is deleted when the observable completes or errors.
        finalize(() => cache.delete(observable)),
        share()
      ), entry.subscription = entry.observable.subscribe(), cache.set(observable, entry);
    }
    const instance = cache.get(observable);
    return instance.subscription.closed && (instance.subscription = instance.observable.subscribe()), {
      subscribe: (onStoreChange) => {
        const subscription = instance.observable.subscribe(onStoreChange);
        return instance.subscription.unsubscribe(), () => {
          subscription.unsubscribe();
        };
      },
      getSnapshot: () => {
        if (instance.error)
          throw instance.error;
        return instance.snapshot;
      }
    };
  }, [observable]);
  return useSyncExternalStore(
    store.subscribe,
    store.getSnapshot,
    typeof initialValueRef.current > "u" ? void 0 : () => initialValueRef.current
  );
}
function useObservableEvent(handleEvent) {
  const [[calls$, call]] = useState(() => observableCallback()), onEvent = useEffectEvent((observable) => handleEvent(observable));
  return useEffect(() => {
    const subscription = calls$.pipe((observable) => onEvent(observable)).subscribe();
    return () => subscription.unsubscribe();
  }, [calls$, onEvent]), call;
}
export {
  useObservable,
  useObservableEvent
};
//# sourceMappingURL=index.js.map
