{"version":3,"file":"PresentationTool.cjs","sources":["../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","../../../channels/src/constants.ts","../../../channels/src/helpers.ts","../../../channels/src/controller.ts","../../../../node_modules/.pnpm/valibot@0.31.1/node_modules/valibot/dist/index.js","../../../visual-editing-helpers/dist/_chunks-es/transformSanityNodeData.js","../../../visual-editing-helpers/dist/index.js","../../src/lib/debounce.ts","../../src/panels/PanelsContext.tsx","../../src/panels/Panel.tsx","../../src/panels/usePanelsStorage.ts","../../src/panels/util.ts","../../src/panels/Panels.tsx","../../src/components/ErrorCard.tsx","../../src/editor/PresentationPaneRouterProvider.tsx","../../src/editor/DocumentListPane.tsx","../../src/editor/DocumentPane.tsx","../../src/editor/DocumentPanel.tsx","../../src/editor/ContentEditor.tsx","../../src/editor/usePreviewState.ts","../../src/panels/PanelResizer.tsx","../../src/panels/usePanelId.ts","../../src/PresentationContent.tsx","../../src/PresentationNavigateProvider.tsx","../../src/PresentationNavigator.tsx","../../src/useLocalState.ts","../../src/PresentationParamsProvider.tsx","../../src/PresentationProvider.tsx","../../src/reducers/presentationReducer.ts","../../src/preview/IFrame.tsx","../../src/preview/PreviewLocationInput.tsx","../../src/preview/ShareUrlMenuItems.tsx","../../src/preview/PreviewFrame.tsx","../../src/useDocumentsOnPage.ts","../../src/useMainDocument.ts","../../src/lib/parse.ts","../../src/useParams.ts","../../src/usePreviewUrl.ts","../../src/PresentationTool.tsx"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import type {ChannelMsgType} from './types'\n\nexport const RESPONSE_TIMEOUT = 1000\nexport const HEARTBEAT_INTERVAL = 1000\nexport const HANDSHAKE_INTERVAL = 500\n\nexport const INTERNAL_MSG_TYPES = [\n  'channel/disconnect',\n  'channel/response',\n  'channel/heartbeat',\n] satisfies ChannelMsgType[]\n\nexport const HANDSHAKE_MSG_TYPES = [\n  'handshake/syn',\n  'handshake/syn-ack',\n  'handshake/ack',\n] satisfies ChannelMsgType[]\n","import {HANDSHAKE_MSG_TYPES, INTERNAL_MSG_TYPES} from './constants'\nimport type {ChannelMsgType, HandshakeMsgType, InternalMsgType} from './types'\n\nexport const isInternalMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is InternalMsgType => {\n  return INTERNAL_MSG_TYPES.some((t) => t === type)\n}\n\nexport const isHandshakeMessage = (\n  type: ChannelMsgType | InternalMsgType,\n): type is HandshakeMsgType => {\n  return HANDSHAKE_MSG_TYPES.some((t) => t === type)\n}\n\nexport const isLegacyHandshakeMessage = ({data = {}}: MessageEvent): boolean => {\n  return (\n    // Check data is a record type\n    typeof data === 'object' &&\n    data !== null &&\n    !Array.isArray(data) &&\n    // The \"domain\" key was introduced in commit 4854e7f\n    !('domain' in data) &&\n    // Check the rest of the object shape is present\n    ['id', 'type', 'from', 'to'].every((key) => key in data) &&\n    // Prior to 4854e7f only handshake events were emitted prior to an established connection\n    data.type.startsWith('handshake/')\n  )\n}\n","import {v4 as uuid} from 'uuid'\n\nimport {HANDSHAKE_INTERVAL, HEARTBEAT_INTERVAL, RESPONSE_TIMEOUT} from './constants'\nimport {isHandshakeMessage, isLegacyHandshakeMessage} from './helpers'\nimport type {\n  ChannelMsg,\n  ChannelsController,\n  ChannelsControllerChannel,\n  ChannelsControllerOptions,\n  ChannelStatus,\n  InternalMsgType,\n  ProtocolMsg,\n  ToArgs,\n} from './types'\n\nexport function createChannelsController<\n  ConnectionIds extends string,\n  Sends extends ChannelMsg,\n  Receives extends ChannelMsg,\n>(\n  config: ChannelsControllerOptions<ConnectionIds, Receives>,\n): ChannelsController<ConnectionIds, Sends> {\n  type Controller = ChannelsController<ConnectionIds, Sends>\n\n  const {destroy, send} = createChannelsControllerInternal<ConnectionIds, Sends, Receives>(config)\n  const sources = new Set<MessageEventSource>()\n  const sendToSource = new WeakMap<MessageEventSource, Controller['send']>()\n  const destroySource = new Set<Controller['destroy']>()\n\n  const sendToMany = ((id, ...args) => {\n    send(id, ...args)\n    for (const source of sources) {\n      if (source && 'closed' in source && !source.closed && sendToSource.has(source)) {\n        const send = sendToSource.get(source)\n        send!(id, ...args)\n      }\n    }\n  }) satisfies Controller['send']\n\n  const destroyMany = (() => {\n    destroy()\n    for (const destroy of destroySource) {\n      destroy()\n    }\n  }) satisfies Controller['destroy']\n\n  return {\n    destroy: destroyMany,\n    send: sendToMany,\n    addSource(source) {\n      if (sources.has(source)) {\n        return\n      }\n      if (!('closed' in source)) {\n        // eslint-disable-next-line no-console\n        console.warn('Source is unsupported', {source})\n        throw new Error('Source is unsupported')\n      }\n      if (source.closed) {\n        throw new Error('Source is closed')\n      }\n      const {send, destroy} = createChannelsControllerInternal<ConnectionIds, Sends, Receives>({\n        ...config,\n        target: source,\n        // @TODO temporary workaround for onStatusUpdate and onEvent not differentiating\n        //       iframes from popups\n        connectTo: config.connectTo.map((prevConnectTo) => {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const {onStatusUpdate, onEvent, ...connectTo} = prevConnectTo\n\n          return {\n            ...connectTo,\n            onEvent: onEvent\n              ? (((...args) => {\n                  const [type] = args\n                  if (\n                    type === 'preview-kit/documents' ||\n                    type === 'overlay/navigate' ||\n                    type === 'loader/documents'\n                  ) {\n                    return\n                  }\n\n                  return onEvent(...args)\n                }) satisfies typeof onEvent)\n              : undefined,\n          }\n        }),\n      })\n      destroySource.add(destroy)\n      sendToSource.set(source, send)\n      sources.add(source)\n    },\n  }\n}\n\nfunction createChannelsControllerInternal<\n  ConnectionIds extends string,\n  Sends extends ChannelMsg,\n  Receives extends ChannelMsg,\n>(\n  config: ChannelsControllerOptions<ConnectionIds, Receives>,\n): Omit<ChannelsController<ConnectionIds, Sends>, 'addSource'> {\n  type Channel = ChannelsControllerChannel<ConnectionIds, Receives>\n\n  const target = config.target\n\n  const channels: Channel[] = config.connectTo.map((config) => ({\n    buffer: [],\n    config,\n    id: '',\n    handler: handshakeHandler,\n    status: 'connecting',\n    interval: undefined,\n    heartbeat: undefined,\n  }))\n\n  function startHandshake(channel: Channel) {\n    channel.id = uuid()\n    channel.interval = window.setInterval(() => {\n      sendHandshake(channel, 'handshake/syn', {id: channel.id})\n    }, HANDSHAKE_INTERVAL)\n  }\n\n  function stopHandshake(channel: Channel) {\n    window.clearInterval(channel.interval)\n  }\n\n  function isValidMessageEvent(e: MessageEvent): e is MessageEvent<ProtocolMsg<Receives>> {\n    const {data, origin} = e\n    return (\n      data.domain === 'sanity/channels' &&\n      data.to == config.id &&\n      channels.map((channel) => channel.config.id).includes(data.from) &&\n      data.type !== 'channel/response' &&\n      origin === config.targetOrigin\n    )\n  }\n\n  function handshakeHandler(e: MessageEvent<ProtocolMsg<Receives>>) {\n    const {data} = e\n    if (isHandshakeMessage(data.type)) {\n      const channel = channels.find((channel) => channel.config.id === data.from)\n      if (channel && data.type === 'handshake/syn-ack') {\n        setChannelStatus(channel, 'connected')\n        sendHandshake(channel, 'handshake/ack', {id: channel.id})\n      }\n    }\n  }\n\n  const messageHandler = ((e: MessageEvent<ProtocolMsg<Receives>>) => {\n    const data = e.data as ProtocolMsg<Receives>\n    if (\n      !isHandshakeMessage(data.type) &&\n      channels.find((channel) => channel.id === data.connectionId)\n    ) {\n      const channel = channels.find((channel) => channel.config.id === data.from)\n      if (channel) {\n        const args = [data.type, data.data] as ToArgs<Receives>\n        channel.config.onEvent?.(...args)\n        config.onEvent?.(...args)\n        send(channel, 'channel/response', {responseTo: data.id}, false)\n      }\n    }\n  }) satisfies Channel['handler']\n\n  function handleEvents(e: MessageEvent<ProtocolMsg<Receives>>) {\n    if (isLegacyHandshakeMessage(e)) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Visual editing package mismatch detected! Please ensure you are using the latest version of Sanity Studio and any packages listed here:\\nhttps://github.com/sanity-io/visual-editing',\n      )\n      return\n    }\n\n    if (isValidMessageEvent(e)) {\n      const {data} = e\n      channels.find((channel) => channel.config.id === data.from)?.handler(e)\n    }\n  }\n\n  function flush(channel: Channel) {\n    const toFlush = [...channel.buffer]\n    channel.buffer.splice(0, channel.buffer.length)\n    toFlush.forEach(({type, data}) => {\n      send(channel, type, data)\n    })\n  }\n\n  function startHeartbeat(channel: Channel) {\n    stopHeartbeat(channel)\n    if (channel.config.heartbeat) {\n      const heartbeatInverval =\n        typeof channel.config.heartbeat === 'number' ? channel.config.heartbeat : HEARTBEAT_INTERVAL\n      channel.heartbeat = window.setInterval(() => {\n        send(channel, 'channel/heartbeat')\n      }, heartbeatInverval)\n    }\n  }\n\n  function stopHeartbeat(channel: Channel) {\n    if (channel.heartbeat) {\n      window.clearInterval(channel.heartbeat)\n    }\n  }\n\n  function setChannelStatus(channel: Channel, next: ChannelStatus) {\n    channel.status = next\n    channel.config.onStatusUpdate?.(next, channel.config.id)\n    config.onStatusUpdate?.(next, channel.config.id)\n    if (next === 'connecting' || next === 'reconnecting') {\n      channel.handler = handshakeHandler\n      stopHeartbeat(channel)\n      startHandshake(channel)\n    } else if (next === 'connected') {\n      channel.handler = messageHandler\n      stopHandshake(channel)\n      startHeartbeat(channel)\n      flush(channel)\n    } else if (next === 'disconnected') {\n      channel.id = null\n      channel.handler = handshakeHandler\n      stopHandshake(channel)\n      stopHeartbeat(channel)\n    }\n  }\n\n  function sendHandshake<T extends Sends['type']>(\n    channel: Channel,\n    type: T,\n    data?: Extract<Sends, {type: T}>['data'],\n  ) {\n    if (!channel.id) {\n      throw new Error('No channel ID set')\n    }\n\n    const msg = {\n      connectionId: channel.id,\n      data,\n      domain: 'sanity/channels',\n      from: config.id,\n      id: uuid(),\n      to: channel.config.id,\n      type,\n    } satisfies ProtocolMsg<Sends>\n\n    try {\n      target?.postMessage(msg, {targetOrigin: '*'})\n    } catch (e) {\n      throw new Error(`Failed to postMessage '${msg.id}' on '${config.id}'`)\n    }\n  }\n\n  function send<T extends Sends['type']>(\n    channel: Channel,\n    type: T | InternalMsgType,\n    data?: Extract<Sends, {type: T}>['data'],\n    expectResponse = true,\n  ) {\n    const id = uuid()\n\n    // If there is no active channel, push to the buffer\n    if (\n      channel.status === 'connecting' ||\n      channel.status === 'reconnecting' ||\n      channel.status === 'disconnected'\n    ) {\n      channel.buffer.push({type, data})\n      return\n    }\n\n    if (!channel.id) {\n      throw new Error('No channel ID set')\n    }\n\n    const msg = {\n      connectionId: channel.id,\n      data,\n      domain: 'sanity/channels',\n      from: config.id,\n      id,\n      to: channel.config.id,\n      type,\n    } satisfies ProtocolMsg<Sends>\n\n    if (expectResponse) {\n      const maxWait = setTimeout(() => {\n        // The channel may have changed, so only reject if the IDs match\n        if (msg.connectionId === channel.id) {\n          // Cleanup the transaction listener\n          window.removeEventListener('message', transact, false)\n          // Push the message to the buffer\n          if (type !== 'channel/heartbeat') {\n            channel.buffer.push({type, data})\n          }\n          // Try to reconnect\n          setChannelStatus(channel, 'reconnecting')\n          // eslint-disable-next-line no-console\n          console.warn(\n            `Received no response to message '${msg.type}' on client '${config.id}' (ID: '${msg.id}').`,\n          )\n        }\n      }, RESPONSE_TIMEOUT)\n\n      const transact = (e: MessageEvent<ChannelMsg>) => {\n        const {data: eventData} = e\n        if (\n          eventData.type === 'channel/response' &&\n          eventData.data?.['responseTo'] &&\n          eventData.data['responseTo'] === msg.id\n        ) {\n          window.removeEventListener('message', transact, false)\n          clearTimeout(maxWait)\n        }\n      }\n      window.addEventListener('message', transact, false)\n    }\n\n    try {\n      target?.postMessage(msg, {targetOrigin: config.targetOrigin})\n    } catch (e) {\n      throw new Error(`Failed to postMessage '${msg.id}' on client '${config.id}'`)\n    }\n  }\n\n  function disconnect() {\n    channels.forEach((channel) => {\n      if (['disconnected'].includes(channel.status)) return\n      send(channel, 'channel/disconnect', {id: channel.id}, false)\n      setChannelStatus(channel, 'disconnected')\n    })\n  }\n\n  function destroy() {\n    disconnect()\n    window.removeEventListener('message', handleEvents, false)\n    channels.forEach((channel) => {\n      stopHeartbeat(channel)\n      stopHandshake(channel)\n    })\n  }\n\n  function initialise() {\n    window.addEventListener('message', handleEvents, false)\n    channels.forEach((channel) => {\n      setChannelStatus(channel, 'connecting')\n    })\n  }\n\n  initialise()\n\n  function sendPublic<T extends Sends['type']>(\n    id: string | string[] | undefined,\n    type: T,\n    data?: Extract<Sends, {type: T}>['data'],\n  ) {\n    const channelsToSend = id ? (Array.isArray(id) ? [...id] : [id]) : channels\n\n    channelsToSend.forEach((id) => {\n      const channel = channels.find((channel) => channel.config.id === id)\n      if (!channel) throw new Error('Invalid channel ID')\n      send(channel, type, data)\n    })\n  }\n\n  return {\n    destroy,\n    send: sendPublic,\n  }\n}\n","// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly,\n    skipPipe: config2?.skipPipe\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2)\n    store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3)\n    store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4)\n    store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference))\n    store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  let type = typeof input;\n  if (type === \"object\") {\n    type = (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type === \"string\" ? `\"${input}\"` : type === \"number\" || type === \"bigint\" || type === \"boolean\" ? `${input}` : type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly,\n    skipPipe: config2.skipPipe\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = (\n    // @ts-expect-error\n    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang)\n  );\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isAllowedObjectKey/_isAllowedObjectKey.ts\nfunction _isAllowedObjectKey(key) {\n  return key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (\"key\" in item && (typeof item.key === \"string\" || typeof item.key === \"number\")) {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/every/every.ts\nfunction every(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every\",\n    reference: every,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/some/some.ts\nfunction some(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some\",\n    reference: some,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    action,\n    _run(dataset) {\n      dataset.value = action(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    action,\n    async _run(dataset) {\n      dataset.value = await action(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, dataset, config2) }\n      ) : dataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date && !isNaN(dataset.value.getTime())) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isAllowedObjectKey(key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isAllowedObjectKey(entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"record\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"record\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isAllowedObjectKey(key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"record\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"record\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key: items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key: items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(items.length).map(async (value2, key) => {\n              return [\n                key + items.length,\n                value2,\n                await rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        dataset = pipe2[index]._run(dataset, config2);\n        const nextAction = pipe2[index + 1];\n        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!\n        nextAction?.kind === \"schema\" || nextAction?.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        dataset = await pipe2[index]._run(dataset, config2);\n        const nextAction = pipe2[index + 1];\n        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!\n        nextAction?.kind === \"schema\" || nextAction?.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isAllowedObjectKey,\n  _isLuhnAlgo,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_,\n  every,\n  excludes,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  readonly,\n  record,\n  recordAsync,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  some,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_\n};\n","import{getPublishedId as t,studioPath as e}from\"@sanity/client/csm\";import{pipe as r,string as o,minLength as s,optional as n,object as a,record as c,unknown as i,is as u,safeParse as p,parse as f}from\"valibot\";function l(t){return\"object\"==typeof t&&null!==t&&!Array.isArray(t)}function d(t){return null!==t&&Array.isArray(t)}function b(t){let e=\"\";for(const r of t)\"string\"!=typeof r?\"number\"!=typeof r?d(r)?(e&&(e+=\":\"),e+=`${r.join(\",\")}}`):r._key&&(e&&(e+=\":\"),e+=`${r._key}`):(e&&(e+=\":\"),e+=`${r}`):(e&&(e+=\".\"),e+=r);return e}const y=/^([A-Za-z]+):([0-9]+)$/,m=/^([A-Za-z]+):([0-9]+),([0-9]+)$/,h=/^([A-Za-z]+):([a-z0-9]+)$/;function k(t){const e=[];for(const r of t.split(\".\")){const t=y.exec(r);if(t){e.push(t[1],Number(t[2]));continue}const o=m.exec(r);if(o){e.push(o[1],[Number(o[2]),Number(o[3])]);continue}const s=h.exec(r);s?e.push(s[1],{_key:s[2]}):e.push(r)}return e}const j=\"drafts.\",w=r(o(),s(1)),A=n(w),U=a({baseUrl:w,dataset:A,id:w,path:w,projectId:A,tool:A,type:A,workspace:A,isDraft:n(o())}),$=a({origin:w,href:w,data:n(c(o(),i()))});function g(t){return u(U,t)}function x(t){return u($,t)}function z(r){const{id:o,path:s,baseUrl:n,tool:a,workspace:c,type:i}=r;return g(r)?[[\"id\",t(o)],[\"type\",i],[\"path\",b(e.fromString(s))],[\"base\",encodeURIComponent(n)],[\"workspace\",c],[\"tool\",a],[\"isDraft\",o.startsWith(j)]].filter((([,t])=>!!t)).map((t=>{const[e,r]=t;return!0===r?e:t.join(\"=\")})).join(\";\"):void 0}function D(t){const r=t.split(\";\").reduce(((t,r)=>{const[o,s]=r.split(\"=\");if(!o||r.includes(\"=\")&&!s)return t;switch(o){case\"id\":t.id=s;break;case\"type\":t.type=s;break;case\"path\":t.path=e.toString(k(s));break;case\"base\":t.baseUrl=decodeURIComponent(s);break;case\"tool\":t.tool=s;break;case\"workspace\":t.workspace=s;break;case\"projectId\":t.projectId=s;break;case\"dataset\":t.dataset=s;break;case\"isDraft\":t.isDraft=\"\"}return t}),{});if(g(r))return r}function I(t){const e=p(U,t);if(e.success)return e.output;const r=p($,t);if(r.success)try{const t=new URL(r.output.href,typeof document>\"u\"?\"https://example.com\":location.origin);return t.searchParams.size>0?f(U,Object.fromEntries(t.searchParams.entries())):r.output}catch(t){return console.error(\"Failed to parse sanity node\",t),r.output}}function N(t){if(\"object\"==typeof t&&null!==t)return I(t);try{return I(JSON.parse(t))}catch{return D(t)}}export{j as D,d as a,g as b,x as c,D as d,z as e,N as f,l as i,b as p,k as u};//# sourceMappingURL=transformSanityNodeData.js.map\n","import{studioPath as t}from\"@sanity/client/csm\";import{e as r}from\"./_chunks-es/transformSanityNodeData.js\";import{p as e,u as n}from\"./_chunks-es/transformSanityNodeData.js\";function o(e){function n(r){return r?\"string\"==typeof r?t.fromString(r):r:[]}function a(e){if(!e.id)throw new Error(\"`id` is required to create a data attribute\");if(!e.type)throw new Error(\"`type` is required to create a data attribute\");if(!e.path||!e.path.length)throw new Error(\"`path` is required to create a data attribute\");const n={baseUrl:e.baseUrl||\"/\",workspace:e.workspace,tool:e.tool,type:e.type,id:e.id,path:\"string\"==typeof e.path?e.path:t.toString(e.path)};return r(n)}const i=t=>a({...e,path:[...n(e.path),...n(t)]});return i.toString=function(){return a(e)},i.combine=function(t){return o({...e,...t})},i.scope=function(t){return o({...e,path:[...n(e.path),...n(t)]})},i}function a(t,r){return`${t}-${\"string\"==typeof r?r:JSON.stringify(r)}`}const i=typeof window<\"u\"&&/Mac|iPod|iPhone|iPad/.test(window.navigator.platform),s={alt:\"altKey\",ctrl:\"ctrlKey\",mod:i?\"metaKey\":\"ctrlKey\",shift:\"shiftKey\"};function p(t,r){return t.every((t=>s[t]?r[s[t]]:r.key===t.toUpperCase()))}function u(t){return t.key===(i?\"Meta\":\"Ctrl\")}function c(t){return\"Alt\"===t.key}export{o as createDataAttribute,a as getQueryCacheKey,c as isAltKey,p as isHotkey,u as isModKey,e as pathToUrlString,n as urlStringToPath};//# sourceMappingURL=index.js.map\n","export function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(\n  fn: F,\n  timeout: number,\n): F {\n  let timer: ReturnType<typeof setTimeout>\n  return ((...args: Parameters<F>) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn.apply(fn, args)\n    }, timeout)\n  }) as F\n}\n","import {createContext, type CSSProperties} from 'react'\n\nimport type {PanelElement, ResizerElement} from './types'\n\nexport const PanelsContext = createContext<{\n  activeResizer: string | null\n  drag: (id: string, event: MouseEvent) => void\n  getPanelStyle: (id: string) => CSSProperties\n  registerElement: (id: string, panel: PanelElement | ResizerElement) => void\n  startDragging: (id: string, event: MouseEvent) => void\n  stopDragging: () => void\n  unregisterElement: (id: string) => void\n} | null>(null)\n\nPanelsContext.displayName = 'PanelsContext'\n","import {type FunctionComponent, type PropsWithChildren, useContext, useLayoutEffect} from 'react'\nimport {styled} from 'styled-components'\n\nimport {PanelsContext} from './PanelsContext'\n\ninterface PanelProps extends PropsWithChildren {\n  defaultSize?: number | null\n  id: string\n  minWidth?: number\n  maxWidth?: number\n  order?: number\n}\n\nconst Root = styled.div`\n  overflow: hidden;\n  flex-basis: 0;\n  flex-shrink: 1;\n`\n\nexport const Panel: FunctionComponent<PanelProps> = function ({\n  children,\n  defaultSize = null,\n  id,\n  minWidth,\n  maxWidth,\n  order = 0,\n}) {\n  const context = useContext(PanelsContext)\n\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`)\n  }\n\n  const {getPanelStyle, registerElement, unregisterElement} = context\n\n  const style = getPanelStyle(id)\n\n  useLayoutEffect(() => {\n    registerElement(id, {\n      id,\n      type: 'panel',\n      defaultSize,\n      maxWidth: maxWidth ?? null,\n      minWidth: minWidth ?? 0,\n      order,\n    })\n\n    return () => {\n      unregisterElement(id)\n    }\n  }, [id, defaultSize, order, maxWidth, minWidth, registerElement, unregisterElement])\n\n  return <Root style={style}>{children}</Root>\n}\n","import {useMemo} from 'react'\n\nimport {debounce} from '../lib/debounce'\nimport type {PanelElement} from './types'\n\nconst itemKey = 'presentation/panels'\n\ntype StoredPanelsState = Record<string, number[]>\n\nconst getStoredItem = () => {\n  // @todo Validate\n  return JSON.parse(localStorage.getItem(itemKey) || '{}') as StoredPanelsState\n}\nconst setStoredItem = (data: StoredPanelsState) => {\n  localStorage.setItem(itemKey, JSON.stringify(data))\n}\n\nconst getKeyForPanels = (panels: PanelElement[]) => {\n  return panels.map((panel) => [panel.id, panel.order].join(':')).join(',')\n}\n\nexport function usePanelsStorage(): {\n  get: (panels: PanelElement[]) => number[] | undefined\n  set: (panels: PanelElement[], widths: number[]) => void\n  setDebounced: (panels: PanelElement[], widths: number[]) => void\n} {\n  return useMemo(() => {\n    const get = (panels: PanelElement[]) => {\n      const stored = getStoredItem()\n      const key = getKeyForPanels(panels)\n      return Array.isArray(stored[key]) && stored[key].some((val) => val === null)\n        ? undefined\n        : stored[key]\n    }\n\n    const set = (panels: PanelElement[], widths: number[]) => {\n      const stored = getStoredItem()\n      const key = getKeyForPanels(panels)\n      const data = {\n        ...stored,\n        [key]: widths,\n      }\n      setStoredItem(data)\n    }\n\n    const setDebounced = debounce(set, 100)\n    return {\n      get,\n      set,\n      setDebounced,\n    }\n  }, [])\n}\n","import type {ElementMap, InitialDragState, PanelElement, PanelsState, ResizerElement} from './types'\n\nfunction getNextWidth(panel: PanelElement, nextWidth: number, containerWidth: number) {\n  const {maxWidth: maxWidthPx, minWidth: minWidthPx} = panel\n  const maxWidth = maxWidthPx == null ? 100 : (maxWidthPx / containerWidth) * 100\n  const minWidth = (minWidthPx / containerWidth) * 100\n  return Math.min(maxWidth, Math.max(minWidth, nextWidth))\n}\n\nexport function getNextWidths(\n  delta: number,\n  containerWidth: number,\n  panelBefore: PanelElement,\n  panelAfter: PanelElement,\n  panelsState: PanelsState,\n  initialDragState: InitialDragState,\n): number[] {\n  const {panels, widths: prevWidths} = panelsState\n  const {widths: initialWidths} = initialDragState\n\n  const widths = initialWidths || prevWidths\n  const nextWidths = [...widths]\n\n  {\n    const pivotPanel = delta < 0 ? panelAfter : panelBefore\n    const index = panels.findIndex((panel) => panel.id === pivotPanel.id)\n    const width = widths[index]\n    const nextWidth = getNextWidth(pivotPanel, width + Math.abs(delta), containerWidth)\n    if (width === nextWidth) {\n      return widths\n    } else {\n      delta = delta < 0 ? width - nextWidth : nextWidth - width\n    }\n  }\n\n  let deltaApplied = 0\n  let pivotPanel = delta < 0 ? panelBefore : panelAfter\n  let index = panels.findIndex((panel) => panel.id === pivotPanel.id)\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const panel = panels[index]\n    const width = widths[index]\n\n    const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied)\n\n    const nextWidth = getNextWidth(panel, width - deltaRemaining, containerWidth)\n\n    if (width !== nextWidth) {\n      deltaApplied += width - nextWidth\n      nextWidths[index] = nextWidth\n\n      if (\n        deltaApplied.toPrecision(10).localeCompare(Math.abs(delta).toPrecision(10), undefined, {\n          numeric: true,\n        }) >= 0\n      ) {\n        break\n      }\n    }\n\n    if (delta < 0) {\n      if (--index < 0) {\n        break\n      }\n    } else {\n      if (++index >= panels.length) {\n        break\n      }\n    }\n  }\n\n  if (deltaApplied === 0) {\n    return widths\n  }\n\n  pivotPanel = delta < 0 ? panelAfter : panelBefore\n  index = panels.findIndex((panel) => panel.id === pivotPanel.id)\n  nextWidths[index] = widths[index] + deltaApplied\n\n  return nextWidths\n}\n\nexport function getPanelWidth(panels: PanelElement[], id: string, widths: number[]): string {\n  if (panels.length === 1) return '100'\n\n  const index = panels.findIndex((panel) => panel.id === id)\n  const width = widths[index]\n\n  if (width == null) return '0'\n\n  return width.toPrecision(10)\n}\n\nexport function getOffset(\n  event: MouseEvent,\n  handleElement: HTMLDivElement,\n  initialOffset: number = 0,\n  initialHandleElementRect: DOMRect | null = null,\n): number {\n  const pointerOffset = event.clientX\n\n  const rect = initialHandleElementRect || handleElement.getBoundingClientRect()\n  const elementOffset = rect.left\n\n  return pointerOffset - elementOffset - initialOffset\n}\n\nexport function isPanel(element: PanelElement | ResizerElement): element is PanelElement {\n  return element.type === 'panel'\n}\n\nexport function isResizer(element: PanelElement | ResizerElement): element is ResizerElement {\n  return element.type === 'resizer'\n}\n\nexport function getSortedElements(elements: ElementMap): Array<PanelElement | ResizerElement> {\n  return Array.from(elements.values()).sort(({order: a}, {order: b}) => {\n    if (a == null && b == null) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n    return a - b\n  })\n}\n\nexport function validateWidths(\n  panels: PanelElement[],\n  widthsToValidate: number[],\n  containerWidth: number,\n): number[] {\n  // Clamp widths proportionally to total 100\n  const total = widthsToValidate.reduce((total, width) => total + width, 0)\n  const widths = [...widthsToValidate].map((width) => (width / total) * 100)\n\n  let remainingWidth = 0\n\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index]\n    const width = widths[index]\n    const nextWidth = getNextWidth(panel, width, containerWidth)\n    if (width != nextWidth) {\n      remainingWidth += width - nextWidth\n      widths[index] = nextWidth\n    }\n  }\n\n  if (remainingWidth.toFixed(3) !== '0.000') {\n    for (let index = 0; index < panels.length; index++) {\n      const panel = panels[index]\n\n      let {maxWidth, minWidth} = panel\n\n      minWidth = (minWidth / containerWidth) * 100\n      if (maxWidth != null) {\n        maxWidth = (maxWidth / containerWidth) * 100\n      }\n\n      const width = Math.min(\n        maxWidth != null ? maxWidth : 100,\n        Math.max(minWidth, widths[index] + remainingWidth),\n      )\n\n      if (width !== widths[index]) {\n        remainingWidth -= width - widths[index]\n        widths[index] = width\n\n        if (Math.abs(remainingWidth).toFixed(3) === '0.000') {\n          break\n        }\n      }\n    }\n  }\n\n  return widths\n}\n\nexport function getDefaultWidths(panels: PanelElement[]): number[] {\n  let panelsWithoutWidth = panels.length\n  let remainingWidthTotal = 100\n\n  const widthsWithNulls = panels.map((panel) => {\n    if (panel.defaultSize) {\n      remainingWidthTotal = remainingWidthTotal - panel.defaultSize\n      panelsWithoutWidth = panelsWithoutWidth - 1\n      return panel.defaultSize\n    }\n    return null\n  })\n\n  const defaultWidth = remainingWidthTotal / panelsWithoutWidth\n  const widths = widthsWithNulls.map((width) => {\n    if (width === null) return defaultWidth\n    return width\n  })\n\n  return widths\n}\n","// Slightly modified version of react-resizable-panels\n// https://github.com/bvaughn/react-resizable-panels/tree/main/packages/react-resizable-panels\n\nimport {\n  type CSSProperties,\n  type FunctionComponent,\n  type PropsWithChildren,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport {styled} from 'styled-components'\n\nimport {PanelsContext} from './PanelsContext'\nimport type {ElementMap, InitialDragState, PanelElement, PanelsState, ResizerElement} from './types'\nimport {usePanelsStorage} from './usePanelsStorage'\nimport {\n  getDefaultWidths,\n  getNextWidths,\n  getOffset,\n  getPanelWidth,\n  getSortedElements,\n  isPanel,\n  isResizer,\n  validateWidths,\n} from './util'\n\nconst PanelsWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  height: 100%;\n  overflow: hidden;\n  width: 100%;\n`\n\nexport const Panels: FunctionComponent<PropsWithChildren> = function ({children}) {\n  const panelsEl = useRef<HTMLDivElement | null>(null)\n\n  const [elements, setElements] = useState<ElementMap>(new Map())\n\n  const panels = useMemo(() => getSortedElements(elements).filter(isPanel), [elements])\n\n  const [widths, setWidths] = useState<number[]>([])\n  const [activeResizer, setActiveResizer] = useState<string | null>(null)\n\n  const panelsRef = useRef<PanelsState>({\n    elements,\n    panels,\n    widths,\n  })\n\n  const getPanelStyle = useCallback(\n    (id: string): CSSProperties => {\n      return {\n        flexGrow: getPanelWidth(panels, id, widths),\n        pointerEvents: activeResizer === null ? undefined : 'none',\n      }\n    },\n    [activeResizer, panels, widths],\n  )\n\n  const registerElement = useCallback((id: string, data: PanelElement | ResizerElement) => {\n    setElements((prev) => {\n      if (prev.has(id)) return prev\n      const next = new Map(prev)\n      next.set(id, data)\n      return next\n    })\n  }, [])\n  const unregisterElement = useCallback((id: string) => {\n    setElements((prev) => {\n      if (!prev.has(id)) return prev\n      const next = new Map(prev)\n      next.delete(id)\n      return next\n    })\n  }, [])\n\n  const dragRef = useRef<InitialDragState>({\n    containerWidth: window.innerWidth,\n    dragOffset: 0,\n    panelAfter: null,\n    panelBefore: null,\n    resizerIndex: -1,\n    resizerRect: null,\n    startX: 0,\n    widths: [],\n  })\n\n  const startDragging = useCallback(\n    (id: string, event: MouseEvent) => {\n      const elementsArr = getSortedElements(elements)\n      const index = elementsArr.findIndex((el) => el.id === id)\n\n      const resizer = elements.get(id)\n      if (!resizer || !isResizer(resizer)) return\n      const resizeElement = resizer.el.current\n      if (!resizeElement) return\n\n      dragRef.current = {\n        resizerIndex: index,\n        panelBefore: elementsArr.reduce(\n          (acc, el, i) => (isPanel(el) && i < index ? el : acc),\n          null as PanelElement | null,\n        ),\n        panelAfter: elementsArr.reduce(\n          (acc, el, i) => (acc === null && isPanel(el) && i > index ? el : acc),\n          null as PanelElement | null,\n        ),\n        containerWidth: window.innerWidth,\n        startX: event.pageX,\n        dragOffset: getOffset(event, resizeElement),\n        resizerRect: resizeElement.getBoundingClientRect(),\n        widths: panelsRef.current.widths,\n      }\n\n      setActiveResizer(id)\n    },\n    [elements],\n  )\n\n  const stopDragging = useCallback(() => {\n    setActiveResizer(null)\n  }, [])\n\n  const drag = useCallback(\n    (id: string, event: MouseEvent) => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      const {containerWidth, dragOffset, panelBefore, panelAfter, resizerRect} = dragRef.current\n\n      if (panelBefore == null || panelAfter == null) {\n        return\n      }\n\n      const resizer = elements.get(id)\n      if (!resizer || !isResizer(resizer)) return\n      const resizeElement = resizer.el.current\n      if (!resizeElement) return\n\n      const offset = getOffset(event, resizeElement, dragOffset, resizerRect)\n\n      if (offset === 0) {\n        return\n      }\n\n      const {widths: prevWidths} = panelsRef.current\n      const rect = panelsEl.current!.getBoundingClientRect()\n      const delta = (offset / rect.width) * 100\n\n      const nextWidths = getNextWidths(\n        delta,\n        containerWidth,\n        panelBefore,\n        panelAfter,\n        panelsRef.current,\n        dragRef.current,\n      )\n\n      const widthsChanged = prevWidths.some((prevWidth, i) => prevWidth !== nextWidths[i])\n\n      if (widthsChanged) {\n        setWidths(nextWidths)\n      }\n    },\n    [elements],\n  )\n\n  // For setting the panels state\n  useLayoutEffect(() => {\n    panelsRef.current.elements = elements\n    panelsRef.current.panels = panels\n    panelsRef.current.widths = widths\n  }, [elements, panels, widths])\n\n  const storage = usePanelsStorage()\n\n  // For setting default sizing when panels are updated\n  useLayoutEffect(() => {\n    const {widths} = panelsRef.current\n\n    if (widths.length === panels.length) {\n      return\n    }\n\n    const storedWidths = storage.get(panels)\n\n    if (storedWidths) {\n      const validatedStoredWidths = validateWidths(panels, storedWidths, window.innerWidth)\n      setWidths(validatedStoredWidths)\n      return\n    }\n\n    const defaultWidths = getDefaultWidths(panels)\n    setWidths(defaultWidths)\n  }, [storage, panels])\n\n  // For storing current widths in localStorage\n  useEffect(() => {\n    if (!widths.length) return\n    storage.setDebounced(panels, widths)\n  }, [storage, panels, widths])\n\n  useLayoutEffect(() => {\n    const resizeObserver = new ResizeObserver(() => {\n      const {panels, widths: prevWidths} = panelsRef.current\n\n      const nextWidths = validateWidths(panels, prevWidths, window.innerWidth)\n\n      const widthsChanged = prevWidths.some((prevWidth, i) => prevWidth !== nextWidths[i])\n      if (widthsChanged) {\n        setWidths(nextWidths)\n      }\n    })\n\n    resizeObserver.observe(panelsEl.current!)\n\n    return () => {\n      resizeObserver.disconnect()\n    }\n  }, [])\n\n  const context = useMemo(\n    () => ({\n      activeResizer,\n      drag,\n      getPanelStyle,\n      registerElement,\n      startDragging,\n      stopDragging,\n      unregisterElement,\n    }),\n    [\n      activeResizer,\n      drag,\n      getPanelStyle,\n      registerElement,\n      startDragging,\n      stopDragging,\n      unregisterElement,\n    ],\n  )\n\n  return (\n    <PanelsContext.Provider value={context}>\n      <PanelsWrapper ref={panelsEl}>{children}</PanelsWrapper>\n    </PanelsContext.Provider>\n  )\n}\n","import {Box, Button, Card, type CardProps, Container, Flex, Inline, Stack, Text} from '@sanity/ui'\nimport type {ReactElement, ReactNode} from 'react'\nimport {useTranslation} from 'sanity'\n\nimport {presentationLocaleNamespace} from '../i18n'\n\nexport function ErrorCard(\n  props: {\n    children?: ReactNode\n    message: string\n    onRetry?: () => void\n    onContinueAnyway?: () => void\n  } & CardProps,\n): ReactElement {\n  const {children, message, onRetry, onContinueAnyway, ...restProps} = props\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n\n  const retryButton = (\n    <Button fontSize={1} mode=\"ghost\" onClick={onRetry} text={t('error-card.retry-button.text')} />\n  )\n  const continueAnywayButton = (\n    <Button\n      fontSize={1}\n      mode=\"ghost\"\n      tone=\"critical\"\n      onClick={onContinueAnyway}\n      text={t('error-card.continue-button.text')}\n    />\n  )\n\n  return (\n    <Card height=\"fill\" {...restProps}>\n      <Flex align=\"center\" height=\"fill\" justify=\"center\">\n        <Container padding={4} sizing=\"border\" width={0}>\n          <Stack space={4}>\n            <Stack space={3}>\n              <Text size={1} weight=\"semibold\">\n                {t('error-card.title')}\n              </Text>\n              <Text muted size={1}>\n                {message}\n              </Text>\n            </Stack>\n\n            {children}\n\n            {onRetry && onContinueAnyway ? (\n              <Inline space={2}>\n                {retryButton}\n                {continueAnywayButton}\n              </Inline>\n            ) : onRetry ? (\n              <Box>{retryButton}</Box>\n            ) : onContinueAnyway ? (\n              <Box>{continueAnywayButton}</Box>\n            ) : null}\n          </Stack>\n        </Container>\n      </Flex>\n    </Card>\n  )\n}\n","/* eslint-disable no-console */\n\nimport {forwardRef, type PropsWithChildren, type ReactElement, useCallback, useMemo} from 'react'\nimport {StateLink, useRouter} from 'sanity/router'\n\nimport {\n  type BackLinkProps,\n  getPublishedId,\n  PaneRouterContext,\n  type PaneRouterContextValue,\n  type ReferenceChildLinkProps,\n  useUnique,\n} from '../internals'\nimport type {\n  PresentationParams,\n  PresentationSearchParams,\n  StructureDocumentPaneParams,\n} from '../types'\n\nfunction encodeQueryString(params: Record<string, unknown> = {}): string {\n  const parts = Object.entries(params)\n    .map(([key, value]) => `${key}=${value}`)\n    .join('&')\n\n  return parts.length ? `?${parts}` : ''\n}\n\nfunction resolveQueryStringFromParams(nextParams: Record<string, string | undefined>) {\n  const allowed = [\n    'comment',\n    'inspect',\n    'instruction',\n    'pathKey',\n    'rev',\n    'since',\n    'template',\n    'prefersLatestPublished',\n    'view',\n  ] satisfies Array<keyof PresentationParams> as string[]\n\n  const safeNextParams = Object.entries(nextParams)\n    .filter(([key]) => allowed.includes(key))\n    .reduce((obj, [key, value]) => {\n      if (value == undefined) return obj\n      return {...obj, [key]: value}\n    }, {})\n\n  return encodeQueryString(safeNextParams)\n}\n\nconst BackLink = forwardRef(function BackLink(\n  props: BackLinkProps & {searchParams: PresentationSearchParams},\n  ref: React.ForwardedRef<HTMLAnchorElement>,\n) {\n  const {searchParams, ...restProps} = props\n  return (\n    <StateLink\n      {...restProps}\n      ref={ref}\n      state={{\n        type: undefined,\n        _searchParams: Object.entries(searchParams),\n      }}\n      title={undefined}\n    />\n  )\n})\n\nconst ReferenceChildLink = forwardRef(function ReferenceChildLink(\n  props: ReferenceChildLinkProps & {searchParams: PresentationSearchParams},\n  ref: React.ForwardedRef<HTMLAnchorElement>,\n) {\n  const {\n    documentId,\n    documentType,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    parentRefPath,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    template,\n    searchParams,\n    ...restProps\n  } = props\n\n  return (\n    <StateLink\n      {...restProps}\n      ref={ref}\n      state={{\n        id: documentId,\n        type: documentType,\n        _searchParams: Object.entries({\n          ...searchParams,\n          prefersLatestPublished: searchParams.perspective === 'published' ? 'true' : undefined,\n        }),\n      }}\n      title={undefined}\n    />\n  )\n})\n\nexport function PresentationPaneRouterProvider(\n  props: PropsWithChildren<{\n    onStructureParams: (params: StructureDocumentPaneParams) => void\n    refs?: {_id: string; _type: string}[]\n    searchParams: PresentationSearchParams\n    structureParams: StructureDocumentPaneParams\n  }>,\n): ReactElement {\n  const {children, onStructureParams, structureParams, searchParams, refs} = props\n\n  const {state: routerState, resolvePathFromState} = useRouter()\n\n  const routerSearchParams = useUnique(Object.fromEntries(routerState._searchParams || []))\n\n  const createPathWithParams: PaneRouterContextValue['createPathWithParams'] = useCallback(\n    (nextParams) => {\n      const path = resolvePathFromState(routerState)\n      const qs = resolveQueryStringFromParams({\n        ...routerSearchParams,\n        ...nextParams,\n      })\n      return `${path}${qs}`\n    },\n    [resolvePathFromState, routerSearchParams, routerState],\n  )\n\n  const context: PaneRouterContextValue = useMemo(() => {\n    return {\n      index: 0,\n      groupIndex: 0,\n      siblingIndex: 0,\n      payload: {},\n      params: structureParams as any,\n      hasGroupSiblings: false,\n      groupLength: 1,\n      routerPanesState: [],\n      ChildLink: (childLinkProps) => {\n        const {childId, ...restProps} = childLinkProps\n        const ref = refs?.find((r) => r._id === childId || getPublishedId(r._id) === childId)\n        if (ref) {\n          return (\n            <StateLink\n              {...restProps}\n              state={{\n                id: childId,\n                type: ref._type,\n                _searchParams: Object.entries({\n                  ...searchParams,\n                  prefersLatestPublished:\n                    searchParams?.perspective === 'published' ? 'true' : undefined,\n                }),\n              }}\n            />\n          )\n        }\n\n        return <div {...restProps} />\n      },\n      BackLink: (backLinkProps) => <BackLink {...backLinkProps} searchParams={searchParams} />,\n      ReferenceChildLink: (childLinkProps) => (\n        <ReferenceChildLink {...childLinkProps} searchParams={searchParams} />\n      ),\n      ParameterizedLink: () => <>ParameterizedLink</>,\n      closeCurrentAndAfter: () => {\n        console.warn('closeCurrentAndAfter')\n      },\n      handleEditReference: (options) => {\n        console.warn('handleEditReference', options)\n      },\n      replaceCurrent: (pane) => {\n        console.warn('replaceCurrent', pane)\n      },\n      closeCurrent: () => {\n        console.warn('closeCurrent')\n      },\n      duplicateCurrent: (pane) => {\n        console.warn('duplicateCurrent', pane)\n      },\n      setView: (viewId) => {\n        console.warn('setView', viewId)\n      },\n      setParams: (nextParams) => {\n        // eslint-disable-next-line no-warning-comments\n        // @todo set inspect param to undefined manually as param is missing from object when closing inspector\n        onStructureParams({\n          ...nextParams,\n          inspect: nextParams['inspect'] ?? undefined,\n        } as StructureDocumentPaneParams)\n      },\n      setPayload: (payload) => {\n        console.warn('setPayload', payload)\n      },\n      navigateIntent: (intentName, intentParams, options) => {\n        console.warn('navigateIntent', intentName, intentParams, options)\n      },\n      createPathWithParams,\n    }\n  }, [createPathWithParams, onStructureParams, refs, searchParams, structureParams])\n\n  return <PaneRouterContext.Provider value={context}>{children}</PaneRouterContext.Provider>\n}\n","import {Card, Code, ErrorBoundary, Flex, Label, Stack} from '@sanity/ui'\nimport {type ErrorInfo, type ReactElement, useCallback, useEffect, useMemo, useState} from 'react'\nimport {useTranslation} from 'sanity'\nimport {styled} from 'styled-components'\n\nimport {ErrorCard} from '../components/ErrorCard'\nimport {presentationLocaleNamespace} from '../i18n'\nimport {\n  DocumentListPane as StructureDocumentListPane,\n  getPublishedId,\n  PaneLayout,\n  type PaneNode,\n  StructureToolProvider,\n} from '../internals'\nimport type {\n  MainDocumentState,\n  PresentationSearchParams,\n  StructureDocumentPaneParams,\n} from '../types'\nimport {usePresentationTool} from '../usePresentationTool'\nimport {PresentationPaneRouterProvider} from './PresentationPaneRouterProvider'\n\nconst RootLayout = styled(PaneLayout)`\n  height: 100%;\n`\n\nconst Root = styled(Flex)`\n  & > div {\n    min-width: none !important;\n    max-width: none !important;\n  }\n`\n\nconst WrappedCode = styled(Code)`\n  white-space: pre-wrap;\n`\n\nexport function DocumentListPane(props: {\n  mainDocumentState?: MainDocumentState\n  onStructureParams: (params: StructureDocumentPaneParams) => void\n  searchParams: PresentationSearchParams\n  refs: {_id: string; _type: string}[]\n}): ReactElement {\n  const {mainDocumentState, onStructureParams, searchParams, refs} = props\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n  const {devMode} = usePresentationTool()\n\n  const ids = useMemo(\n    () =>\n      refs\n        .filter((r) => getPublishedId(r._id) !== mainDocumentState?.document?._id)\n        .map((r) => r._id),\n    [mainDocumentState, refs],\n  )\n\n  const pane: Extract<PaneNode, {type: 'documentList'}> = useMemo(\n    () => ({\n      id: '$root',\n      options: {\n        filter: '_id in $ids',\n        params: {ids},\n        // defaultOrdering: [{field: '_updatedAt', direction: 'desc'}],\n      },\n      schemaTypeName: '',\n      title: t('document-list-pane.document-list.title'),\n      type: 'documentList',\n    }),\n    [ids, t],\n  )\n\n  const [errorParams, setErrorParams] = useState<{\n    info: ErrorInfo\n    error: Error\n  } | null>(null)\n\n  const handleRetry = useCallback(() => setErrorParams(null), [])\n\n  const [structureParams] = useState(() => ({}))\n\n  // Reset error state when `refs` value schanges\n  useEffect(() => setErrorParams(null), [refs])\n\n  if (errorParams) {\n    return (\n      <ErrorCard flex={1} message={t('document-list-pane.error.text')} onRetry={handleRetry}>\n        {devMode && (\n          // show runtime error message in dev mode\n          <Card overflow=\"auto\" padding={3} radius={2} tone=\"critical\">\n            <Stack space={3}>\n              <Label muted size={0}>\n                {t('presentation-error.label')}\n              </Label>\n              <WrappedCode size={1}>{errorParams.error.message}</WrappedCode>\n            </Stack>\n          </Card>\n        )}\n      </ErrorCard>\n    )\n  }\n\n  return (\n    <ErrorBoundary onCatch={setErrorParams}>\n      <RootLayout>\n        <StructureToolProvider>\n          <PresentationPaneRouterProvider\n            onStructureParams={onStructureParams}\n            structureParams={structureParams}\n            searchParams={searchParams}\n            refs={refs}\n          >\n            <Root direction=\"column\" flex={1}>\n              <StructureDocumentListPane index={0} itemId=\"$root\" pane={pane} paneKey=\"$root\" />\n            </Root>\n          </PresentationPaneRouterProvider>\n        </StructureToolProvider>\n      </RootLayout>\n    </ErrorBoundary>\n  )\n}\n","import {Card, Code, ErrorBoundary, Label, Stack} from '@sanity/ui'\nimport {type ErrorInfo, type ReactElement, useCallback, useEffect, useMemo, useState} from 'react'\nimport {type Path, useTranslation} from 'sanity'\nimport {styled} from 'styled-components'\n\nimport {ErrorCard} from '../components/ErrorCard'\nimport {presentationLocaleNamespace} from '../i18n'\nimport {\n  decodeJsonParams,\n  DocumentPane as StructureDocumentPane,\n  type DocumentPaneNode,\n  PaneLayout,\n} from '../internals'\nimport type {PresentationSearchParams, StructureDocumentPaneParams} from '../types'\nimport {usePresentationTool} from '../usePresentationTool'\nimport {PresentationPaneRouterProvider} from './PresentationPaneRouterProvider'\n\nconst WrappedCode = styled(Code)`\n  white-space: pre-wrap;\n`\n\nexport function DocumentPane(props: {\n  documentId: string\n  documentType: string\n  onFocusPath: (path: Path) => void\n  onStructureParams: (params: StructureDocumentPaneParams) => void\n  structureParams: StructureDocumentPaneParams\n  searchParams: PresentationSearchParams\n}): ReactElement {\n  const {documentId, documentType, onFocusPath, onStructureParams, searchParams, structureParams} =\n    props\n  const {template, templateParams} = structureParams\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n  const {devMode} = usePresentationTool()\n\n  const paneDocumentNode: DocumentPaneNode = useMemo(\n    () => ({\n      id: documentId,\n      options: {\n        id: documentId,\n        type: documentType,\n        template,\n        templateParameters: decodeJsonParams(templateParams),\n      },\n      title: '',\n      type: 'document',\n    }),\n    [documentId, documentType, template, templateParams],\n  )\n\n  const [errorParams, setErrorParams] = useState<{\n    info: ErrorInfo\n    error: Error\n  } | null>(null)\n\n  const handleRetry = useCallback(() => setErrorParams(null), [])\n\n  // Reset error state when parameters change\n  useEffect(() => {\n    setErrorParams(null)\n  }, [documentId, documentType, structureParams])\n\n  if (errorParams) {\n    return (\n      <ErrorCard flex={1} message={t('document-pane.error.text')} onRetry={handleRetry}>\n        {devMode && (\n          // show runtime error message in dev mode\n          <Card overflow=\"auto\" padding={3} radius={2} tone=\"critical\">\n            <Stack space={3}>\n              <Label muted size={0}>\n                {t('presentation-error.label')}\n              </Label>\n              <WrappedCode size={1}>{errorParams.error.message}</WrappedCode>\n            </Stack>\n          </Card>\n        )}\n      </ErrorCard>\n    )\n  }\n\n  return (\n    <ErrorBoundary onCatch={setErrorParams}>\n      <PaneLayout style={{height: '100%'}}>\n        <PresentationPaneRouterProvider\n          searchParams={searchParams}\n          onStructureParams={onStructureParams}\n          structureParams={structureParams}\n        >\n          <StructureDocumentPane\n            paneKey=\"document\"\n            index={1}\n            itemId=\"document\"\n            pane={paneDocumentNode}\n            onFocusPath={onFocusPath}\n          />\n        </PresentationPaneRouterProvider>\n      </PaneLayout>\n    </ErrorBoundary>\n  )\n}\n","import {type ReactElement} from 'react'\nimport {type Path} from 'sanity'\n\nimport {StructureToolProvider} from '../internals'\nimport type {PresentationSearchParams, StructureDocumentPaneParams} from '../types'\nimport {DocumentPane} from './DocumentPane'\n\nexport function DocumentPanel(props: {\n  documentId: string\n  documentType: string\n  onFocusPath: (path: Path) => void\n  onStructureParams: (params: StructureDocumentPaneParams) => void\n  searchParams: PresentationSearchParams\n  structureParams: StructureDocumentPaneParams\n}): ReactElement {\n  const {documentId, documentType, onFocusPath, onStructureParams, searchParams, structureParams} =\n    props\n  return (\n    <StructureToolProvider>\n      <DocumentPane\n        documentId={documentId}\n        documentType={documentType}\n        onFocusPath={onFocusPath}\n        onStructureParams={onStructureParams}\n        searchParams={searchParams}\n        structureParams={structureParams}\n      />\n    </StructureToolProvider>\n  )\n}\n","import {WarningOutlineIcon} from '@sanity/icons'\nimport {Box, Card, Flex, Text} from '@sanity/ui'\nimport {type HTMLProps, type ReactElement, useCallback, useMemo} from 'react'\nimport {StateLink} from 'sanity/router'\n\nimport {presentationLocaleNamespace} from '../i18n'\nimport {\n  getPreviewValueWithFallback,\n  type Path,\n  PreviewCard,\n  SanityDefaultPreview,\n  type SanityDocument,\n  Translate,\n  useSchema,\n  useTranslation,\n} from '../internals'\nimport type {\n  MainDocumentState,\n  PresentationSearchParams,\n  StructureDocumentPaneParams,\n} from '../types'\nimport {DocumentListPane} from './DocumentListPane'\nimport {DocumentPanel} from './DocumentPanel'\nimport usePreviewState from './usePreviewState'\n\nexport function ContentEditor(props: {\n  documentId?: string\n  documentType?: string\n  mainDocumentState?: MainDocumentState\n  onFocusPath: (path: Path) => void\n  onStructureParams: (params: StructureDocumentPaneParams) => void\n  refs: {_id: string; _type: string}[]\n  structureParams: StructureDocumentPaneParams\n  searchParams: PresentationSearchParams\n}): ReactElement {\n  const {\n    documentId,\n    documentType,\n    mainDocumentState,\n    onFocusPath,\n    onStructureParams,\n    refs,\n    searchParams,\n    structureParams,\n  } = props\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n  const schema = useSchema()\n\n  const MainDocumentLink = useCallback(\n    (props: HTMLProps<HTMLAnchorElement>) => {\n      return (\n        <StateLink\n          {...props}\n          state={{\n            id: mainDocumentState!.document!._id,\n            type: mainDocumentState!.document!._type,\n            _searchParams: Object.entries({\n              ...searchParams,\n              prefersLatestPublished:\n                searchParams?.perspective === 'published' ? 'true' : undefined,\n            }),\n          }}\n        />\n      )\n    },\n    [mainDocumentState, searchParams],\n  )\n\n  const schemaType = useMemo(\n    () => schema.get(mainDocumentState?.document?._type || 'shoe')!,\n    [mainDocumentState, schema],\n  )\n\n  const previewState = usePreviewState(mainDocumentState?.document?._id || '', schemaType)\n\n  const preview = useMemo(() => {\n    if (!mainDocumentState?.document) return null\n\n    return (\n      <SanityDefaultPreview\n        {...getPreviewValueWithFallback({\n          value: mainDocumentState!.document! as SanityDocument,\n          published: previewState.published,\n          draft: previewState.draft,\n        })}\n        schemaType={schemaType}\n        status={\n          <Card padding={1} radius={2} shadow={1}>\n            <Text muted size={0} weight=\"medium\">\n              {t('main-document.label')}\n            </Text>\n          </Card>\n        }\n      />\n    )\n  }, [mainDocumentState, schemaType, t, previewState])\n\n  if (documentId && documentType) {\n    return (\n      <DocumentPanel\n        documentId={documentId}\n        documentType={documentType}\n        onFocusPath={onFocusPath}\n        onStructureParams={onStructureParams}\n        searchParams={searchParams}\n        structureParams={structureParams}\n      />\n    )\n  }\n\n  return (\n    <Flex direction=\"column\" flex={1} height=\"fill\">\n      {mainDocumentState && (\n        <Card padding={3} tone={mainDocumentState.document ? 'inherit' : 'caution'}>\n          {mainDocumentState.document ? (\n            <PreviewCard\n              __unstable_focusRing\n              as={MainDocumentLink as any}\n              data-as=\"a\"\n              radius={2}\n              sizing=\"border\"\n              tone=\"inherit\"\n            >\n              {preview}\n            </PreviewCard>\n          ) : (\n            <Card padding={2} radius={2} tone=\"inherit\">\n              <Flex gap={3}>\n                <Box flex=\"none\">\n                  <Text size={1}>\n                    <WarningOutlineIcon />\n                  </Text>\n                </Box>\n                <Box flex={1}>\n                  <Text size={1}>\n                    <Translate\n                      t={t}\n                      i18nKey=\"main-document.missing.text\"\n                      components={{Code: 'code'}}\n                      values={{path: mainDocumentState.path}}\n                    />\n                  </Text>\n                </Box>\n              </Flex>\n            </Card>\n          )}\n        </Card>\n      )}\n\n      <DocumentListPane\n        mainDocumentState={mainDocumentState}\n        onStructureParams={onStructureParams}\n        searchParams={searchParams}\n        refs={refs}\n      />\n    </Flex>\n  )\n}\n","import {type SchemaType} from '@sanity/types'\nimport {useEffect, useState} from 'react'\n\nimport {\n  getPreviewStateObservable,\n  type PreviewValue,\n  type SanityDocument,\n  useDocumentPreviewStore,\n} from '../internals'\n\ninterface PreviewState {\n  isLoading?: boolean\n  draft?: PreviewValue | Partial<SanityDocument> | null\n  published?: PreviewValue | Partial<SanityDocument> | null\n}\n\nexport default function usePreviewState(documentId: string, schemaType?: SchemaType): PreviewState {\n  const documentPreviewStore = useDocumentPreviewStore()\n  const [preview, setPreview] = useState<PreviewState>({})\n\n  useEffect(() => {\n    if (!schemaType) {\n      return undefined\n    }\n    const subscription = getPreviewStateObservable(\n      documentPreviewStore,\n      schemaType,\n      documentId,\n      '',\n    ).subscribe((state) => {\n      setPreview(state)\n    })\n\n    return () => {\n      subscription?.unsubscribe()\n    }\n  }, [documentPreviewStore, schemaType, documentId])\n\n  return preview\n}\n","import {\n  type FunctionComponent,\n  type MouseEvent as ReactMouseEvent,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n} from 'react'\nimport {styled} from 'styled-components'\n\nimport {PanelsContext} from './PanelsContext'\nimport {usePanelId} from './usePanelId'\n\nconst Resizer = styled.div`\n  position: relative;\n`\nconst ResizerInner = styled.div<{\n  $disabled: boolean\n}>`\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: -5px;\n  width: 9px;\n  z-index: 10;\n  cursor: ${({$disabled}) => ($disabled ? 'auto' : 'ew-resize')};\n\n  /* Border */\n  & > span:nth-child(1) {\n    display: block;\n    border-left: 1px solid var(--card-border-color);\n    position: absolute;\n    top: 0;\n    left: 4px;\n    bottom: 0;\n    transition: opacity 200ms;\n  }\n\n  ${({$disabled}) =>\n    !$disabled &&\n    `\n    /* Hover effect */\n    & > span:nth-child(2) {\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 9px;\n      bottom: 0;\n      background-color: var(--card-border-color);\n      opacity: 0;\n      transition: opacity 150ms;\n    }\n\n    @media (hover: hover) {\n      &:hover > span:nth-child(2) {\n        opacity: 0.2;\n      }\n    }\n  `}\n`\n\nexport const PanelResizer: FunctionComponent<{\n  id?: string\n  order: number\n  disabled?: boolean\n}> = function ({id: propId, order, disabled = false}) {\n  const el = useRef<HTMLDivElement>(null)\n\n  const context = useContext(PanelsContext)\n\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`)\n  }\n\n  const id = usePanelId(propId)\n\n  const {activeResizer, drag, startDragging, stopDragging, registerElement, unregisterElement} =\n    context\n\n  const isDragging = activeResizer === id\n\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`)\n  }\n\n  const onMouseDown = useCallback(\n    (event: ReactMouseEvent) => {\n      startDragging(id, event.nativeEvent)\n    },\n    [id, startDragging],\n  )\n\n  const onDrag = useCallback(\n    (e: MouseEvent) => {\n      drag(id, e)\n    },\n    [id, drag],\n  )\n\n  const onDragStop = useCallback(() => {\n    el.current!.blur()\n    stopDragging()\n  }, [stopDragging])\n\n  useEffect(() => {\n    if (!isDragging || disabled) return\n\n    // Set styles to prevent text selection and force an ew-resize cursor whilst\n    // dragging. Return a reset callback so we can revert to any values that\n    // might have been present before dragging started.\n    function setDocumentStyles() {\n      const bodyStyle = document.body.style\n      const documentStyle = document.documentElement.style\n\n      const {cursor} = documentStyle\n      const {userSelect} = bodyStyle\n\n      documentStyle.cursor = 'ew-resize'\n      bodyStyle.userSelect = 'none'\n\n      return () => {\n        if (cursor) documentStyle.cursor = cursor\n        else documentStyle.removeProperty('cursor')\n\n        if (userSelect) bodyStyle.userSelect = userSelect\n        else bodyStyle.removeProperty('user-select')\n      }\n    }\n\n    const resetDocumentStyles = setDocumentStyles()\n    window.addEventListener('mousemove', onDrag)\n    window.addEventListener('mouseup', onDragStop)\n    window.addEventListener('contextmenu', onDragStop)\n\n    return () => {\n      resetDocumentStyles()\n      window.removeEventListener('mousemove', onDrag)\n      window.removeEventListener('mouseup', onDragStop)\n      window.removeEventListener('contextmenu', onDragStop)\n    }\n  }, [disabled, isDragging, onDrag, onDragStop])\n\n  useLayoutEffect(() => {\n    registerElement(id, {id, order, type: 'resizer', el})\n\n    return () => {\n      unregisterElement(id)\n    }\n  }, [id, order, registerElement, unregisterElement])\n\n  return (\n    <Resizer onMouseDown={onMouseDown} ref={el}>\n      <ResizerInner $disabled={disabled}>\n        <span />\n        <span />\n      </ResizerInner>\n    </Resizer>\n  )\n}\n","import {useRef} from 'react'\nimport {v4 as uuid} from 'uuid'\n\nexport function usePanelId(id?: string): string {\n  const idRef = useRef(id || uuid())\n  return idRef.current\n}\n","import {\n  type Dispatch,\n  type FunctionComponent,\n  type PropsWithChildren,\n  type SetStateAction,\n} from 'react'\nimport type {Path, SanityDocument} from 'sanity'\n\nimport {ContentEditor} from './editor/ContentEditor'\nimport {type CommentIntentGetter, CommentsIntentProvider} from './internals'\nimport {DisplayedDocumentBroadcasterProvider} from './loader/DisplayedDocumentBroadcaster'\nimport {Panel} from './panels/Panel'\nimport {PanelResizer} from './panels/PanelResizer'\nimport type {\n  MainDocumentState,\n  PresentationParams,\n  PresentationSearchParams,\n  StructureDocumentPaneParams,\n} from './types'\n\nexport interface PresentationContentProps {\n  documentId: PresentationParams['id']\n  documentsOnPage: {_id: string; _type: string}[]\n  documentType: PresentationParams['type']\n  getCommentIntent: CommentIntentGetter\n  mainDocumentState: MainDocumentState | undefined\n  onFocusPath: (path: Path) => void\n  onStructureParams: (params: StructureDocumentPaneParams) => void\n  searchParams: PresentationSearchParams\n  setDisplayedDocument: Dispatch<SetStateAction<Partial<SanityDocument> | null | undefined>>\n  structureParams: StructureDocumentPaneParams\n}\n\nconst PresentationContentWrapper: FunctionComponent<\n  PropsWithChildren<{\n    documentId?: string\n    getCommentIntent: CommentIntentGetter\n    setDisplayedDocument: Dispatch<SetStateAction<Partial<SanityDocument> | null | undefined>>\n  }>\n> = (props) => {\n  const {documentId, setDisplayedDocument, getCommentIntent} = props\n  return (\n    <>\n      <PanelResizer order={4} />\n      <Panel id=\"content\" minWidth={325} order={5}>\n        <DisplayedDocumentBroadcasterProvider\n          documentId={documentId}\n          setDisplayedDocument={setDisplayedDocument}\n        >\n          <CommentsIntentProvider getIntent={getCommentIntent}>\n            {props.children}\n          </CommentsIntentProvider>\n        </DisplayedDocumentBroadcasterProvider>\n      </Panel>\n    </>\n  )\n}\n\nexport const PresentationContent: FunctionComponent<PresentationContentProps> = (props) => {\n  const {\n    documentId,\n    documentsOnPage,\n    documentType,\n    getCommentIntent,\n    mainDocumentState,\n    onFocusPath,\n    onStructureParams,\n    searchParams,\n    setDisplayedDocument,\n    structureParams,\n  } = props\n\n  return (\n    <PresentationContentWrapper\n      documentId={documentId}\n      getCommentIntent={getCommentIntent}\n      setDisplayedDocument={setDisplayedDocument}\n    >\n      <ContentEditor\n        documentId={documentId}\n        documentType={documentType}\n        mainDocumentState={mainDocumentState}\n        onFocusPath={onFocusPath}\n        onStructureParams={onStructureParams}\n        refs={documentsOnPage}\n        searchParams={searchParams}\n        structureParams={structureParams}\n      />\n    </PresentationContentWrapper>\n  )\n}\n","import {type FunctionComponent, type PropsWithChildren, useCallback} from 'react'\n\nimport {\n  PresentationNavigateContext,\n  type PresentationNavigateContextValue,\n} from './PresentationNavigateContext'\nimport type {PresentationNavigate} from './types'\n\nexport const PresentationNavigateProvider: FunctionComponent<\n  PropsWithChildren<{\n    navigate: PresentationNavigate\n  }>\n> = function (props) {\n  const {children, navigate: _navigate} = props\n\n  const navigate = useCallback<PresentationNavigateContextValue>(\n    (preview, document = undefined) => {\n      _navigate(document || {}, preview ? {preview} : {})\n    },\n    [_navigate],\n  )\n\n  return (\n    <PresentationNavigateContext.Provider value={navigate}>\n      {children}\n    </PresentationNavigateContext.Provider>\n  )\n}\n","import {memo, useCallback, useMemo} from 'react'\n\nimport {Panel} from './panels/Panel'\nimport {PanelResizer} from './panels/PanelResizer'\nimport type {NavigatorOptions} from './types'\nimport {useLocalState} from './useLocalState'\n\n/** @internal */\nexport interface UsePresentationNavigatorProps {\n  unstable_navigator?: NavigatorOptions\n}\n\n/** @internal */\nexport interface UsePresentationNavigatorState {\n  navigatorEnabled: boolean\n  toggleNavigator: (() => void) | undefined\n}\n\n/** @internal */\nexport function usePresentationNavigator(\n  props: UsePresentationNavigatorProps,\n): [UsePresentationNavigatorState, () => JSX.Element] {\n  const {unstable_navigator} = props\n\n  const navigatorProvided = !!unstable_navigator?.component\n  const [_navigatorEnabled, setNavigatorEnabled] = useLocalState<boolean>(\n    'presentation/navigator',\n    navigatorProvided,\n  )\n  const navigatorEnabled = navigatorProvided ? _navigatorEnabled : false\n  const toggleNavigator = useMemo(() => {\n    if (!navigatorProvided) return undefined\n\n    return () => setNavigatorEnabled((enabled) => !enabled)\n  }, [navigatorProvided, setNavigatorEnabled])\n\n  const Component = useCallback(\n    function PresentationNavigator() {\n      return <>{navigatorEnabled && <Navigator {...unstable_navigator!} />}</>\n    },\n    [navigatorEnabled, unstable_navigator],\n  )\n\n  return [{navigatorEnabled, toggleNavigator}, Component]\n}\n\nfunction NavigatorComponent(props: NavigatorOptions) {\n  const {minWidth, maxWidth, component: NavigatorComponent} = props\n  const navigatorDisabled = minWidth != null && maxWidth != null && minWidth === maxWidth\n  return (\n    <>\n      <Panel id=\"navigator\" minWidth={minWidth} maxWidth={maxWidth} order={1}>\n        <NavigatorComponent />\n      </Panel>\n      <PanelResizer order={2} disabled={navigatorDisabled} />\n    </>\n  )\n}\nconst Navigator = memo(NavigatorComponent)\n","import {type Dispatch, type SetStateAction, useEffect, useState} from 'react'\n\nexport function useLocalState<T>(key: string, defaultValue: T): [T, Dispatch<SetStateAction<T>>] {\n  const [value, setValue] = useState<T>(() =>\n    JSON.parse(localStorage.getItem(key) ?? JSON.stringify(defaultValue)),\n  )\n\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value))\n  }, [key, value])\n\n  return [value, setValue]\n}\n","import {type FunctionComponent, type PropsWithChildren, useMemo} from 'react'\n\nimport {PresentationParamsContext} from './PresentationParamsContext'\nimport type {PresentationParams} from './types'\n\nexport const PresentationParamsProvider: FunctionComponent<\n  PropsWithChildren<{\n    params: PresentationParams\n  }>\n> = function (props) {\n  const {children, params} = props\n\n  const context = useMemo<PresentationParams>(() => params, [params])\n\n  return (\n    <PresentationParamsContext.Provider value={context}>\n      {children}\n    </PresentationParamsContext.Provider>\n  )\n}\n","import {type FunctionComponent, type PropsWithChildren, useMemo} from 'react'\n\nimport {PresentationContext, type PresentationContextValue} from './PresentationContext'\nimport type {\n  PresentationNavigate,\n  PresentationParams,\n  PresentationSearchParams,\n  StructureDocumentPaneParams,\n} from './types'\n\nexport const PresentationProvider: FunctionComponent<\n  PropsWithChildren<{\n    devMode: boolean\n    name: string\n    navigate: PresentationNavigate\n    params: PresentationParams\n    searchParams: PresentationSearchParams\n    structureParams: StructureDocumentPaneParams\n  }>\n> = function (props) {\n  const {children, devMode, name, navigate, params, searchParams, structureParams} = props\n\n  const context = useMemo<PresentationContextValue>(\n    () => ({\n      devMode,\n      name,\n      navigate,\n      params,\n      searchParams,\n      structureParams,\n    }),\n    [devMode, name, navigate, params, searchParams, structureParams],\n  )\n\n  return <PresentationContext.Provider value={context}>{children}</PresentationContext.Provider>\n}\n","import type {Dispatch, Reducer} from 'react'\nimport {boolean, fallback, object, parse, picklist} from 'valibot'\n\nexport interface PresentationState {\n  mainDocument: boolean\n  iframe: {\n    status: 'loading' | 'loaded' | 'refreshing' | 'reloading'\n  }\n  visualEditing: {\n    overlaysEnabled: boolean\n  }\n}\n\nexport const ACTION_IFRAME_LOADED = 'ACTION_IFRAME_LOADED'\nexport const ACTION_IFRAME_REFRESH = 'ACTION_IFRAME_REFRESH'\nexport const ACTION_IFRAME_RELOAD = 'ACTION_IFRAME_RELOAD'\nexport const ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE = 'ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE'\n\ninterface IframeLoadedAction {\n  type: typeof ACTION_IFRAME_LOADED\n}\ninterface IframeRefreshAction {\n  type: typeof ACTION_IFRAME_REFRESH\n}\ninterface IframeReloadAction {\n  type: typeof ACTION_IFRAME_RELOAD\n}\ninterface VisualEditingOverlaysToggleAction {\n  type: typeof ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE\n  enabled: boolean\n}\n\ntype PresentationAction =\n  | IframeLoadedAction\n  | IframeRefreshAction\n  | IframeReloadAction\n  | VisualEditingOverlaysToggleAction\n\nexport const presentationReducer: Reducer<\n  Readonly<PresentationState>,\n  Readonly<PresentationAction>\n> = (state, action) => {\n  switch (action.type) {\n    case ACTION_IFRAME_LOADED:\n      return state.iframe.status === 'loaded'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'loaded',\n            },\n          }\n    case ACTION_IFRAME_REFRESH:\n      return state.iframe.status === 'refreshing'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'refreshing',\n            },\n          }\n    case ACTION_IFRAME_RELOAD:\n      return state.iframe.status === 'reloading'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'reloading',\n            },\n          }\n    case ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE:\n      return toggleVisualEditingOverlays(state, action)\n    default:\n      return state\n  }\n}\n\nconst toggleVisualEditingOverlays: Reducer<\n  Readonly<PresentationState>,\n  Readonly<VisualEditingOverlaysToggleAction>\n> = (state, action) => {\n  if (state.visualEditing.overlaysEnabled === action.enabled) return state\n  return {\n    ...state,\n    visualEditing: {\n      ...state.visualEditing,\n      overlaysEnabled: action.enabled,\n    },\n  }\n}\n\nconst mainDocumentSchema = fallback(boolean(), false)\n\nconst iframeStatusSchema = picklist(['loading', 'loaded', 'refreshing', 'reloading'])\n\nconst initStateSchema = object({\n  mainDocument: mainDocumentSchema,\n  iframe: object({\n    status: iframeStatusSchema,\n  }),\n  visualEditing: object({overlaysEnabled: boolean()}),\n})\n\nconst INITIAL_PRESENTATION_STATE = {\n  mainDocument: false,\n  iframe: {\n    status: 'loading',\n  },\n  visualEditing: {\n    overlaysEnabled: false,\n  },\n} as const satisfies PresentationState\n\nexport function presentationReducerInit(\n  state: Readonly<Partial<PresentationState>>,\n): Readonly<PresentationState> {\n  return parse(initStateSchema, {...INITIAL_PRESENTATION_STATE, ...state})\n}\n\nexport type DispatchPresentationAction = Dispatch<Readonly<PresentationAction>>\n","import {Box} from '@sanity/ui'\nimport {motion, type VariantLabels, type Variants} from 'framer-motion'\nimport {forwardRef, type ReactEventHandler} from 'react'\nimport {styled} from 'styled-components'\n\nconst IFrameElement = motion(styled.iframe`\n  box-shadow: 0 0 0 1px var(--card-border-color);\n  border-top: 1px solid transparent;\n  border-bottom: 0;\n  border-right: 0;\n  border-left: 0;\n  max-height: 100%;\n  width: 100%;\n`)\n\nconst IFrameOverlay = styled(Box)`\n  position: absolute;\n  inset: 0;\n  background: transparent;\n`\n\ninterface IFrameProps {\n  animate: VariantLabels\n  initial: VariantLabels\n  onLoad: ReactEventHandler<HTMLIFrameElement>\n  preventClick: boolean\n  src: string\n  variants: Variants\n}\n\nexport const IFrame = forwardRef<HTMLIFrameElement, IFrameProps>(function IFrame(props, ref) {\n  const {animate, initial, onLoad, preventClick, src, variants} = props\n\n  return (\n    <>\n      <IFrameElement\n        animate={animate}\n        initial={initial}\n        onLoad={onLoad}\n        ref={ref}\n        src={src}\n        variants={variants}\n      />\n      {preventClick && <IFrameOverlay />}\n    </>\n  )\n})\n","import {ResetIcon} from '@sanity/icons'\nimport {TextInput, type TextInputClearButtonProps} from '@sanity/ui'\nimport {\n  type ChangeEvent,\n  type FunctionComponent,\n  type KeyboardEvent,\n  type ReactNode,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport {useTranslation} from 'sanity'\n\nimport {presentationLocaleNamespace} from '../i18n'\nimport {useActiveWorkspace} from '../internals'\n\nexport const PreviewLocationInput: FunctionComponent<{\n  fontSize?: number\n  onChange: (value: string) => void\n  origin: string\n  padding?: number\n  prefix?: ReactNode\n  suffix?: ReactNode\n  value: string\n}> = function (props) {\n  const {fontSize = 1, onChange, origin, padding = 3, prefix, suffix, value} = props\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n  const {basePath = '/'} = useActiveWorkspace()?.activeWorkspace || {}\n\n  const inputRef = useRef<HTMLInputElement | null>(null)\n  const [sessionValue, setSessionValue] = useState<string | undefined>(undefined)\n  const [customValidity, setCustomValidity] = useState<string | undefined>(undefined)\n\n  const handleChange = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    setSessionValue(event.currentTarget.value)\n  }, [])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLInputElement>) => {\n      if (event.key === 'Enter') {\n        if (sessionValue === undefined) {\n          return\n        }\n\n        const absoluteValue =\n          sessionValue.startsWith('/') || sessionValue === ''\n            ? `${origin}${sessionValue}`\n            : sessionValue\n\n        if (!absoluteValue.startsWith(origin + '/') && absoluteValue !== origin) {\n          setCustomValidity(t('preview-location-input.error', {origin, context: 'missing-origin'}))\n          return\n        }\n        // `origin` is an empty string '' if the Studio is embedded, and that's when we need to protect against recursion\n        if (!origin && (absoluteValue.startsWith(`${basePath}/`) || absoluteValue === basePath)) {\n          setCustomValidity(\n            t('preview-location-input.error', {basePath, context: 'same-base-path'}),\n          )\n          return\n        }\n\n        const nextValue = absoluteValue === origin ? origin + '/' : absoluteValue\n\n        setCustomValidity(undefined)\n        setSessionValue(undefined)\n\n        onChange(nextValue.slice(origin.length))\n\n        inputRef.current?.blur()\n      }\n\n      if (event.key === 'Escape') {\n        setCustomValidity(undefined)\n        setSessionValue(undefined)\n      }\n    },\n    [basePath, onChange, origin, sessionValue, t],\n  )\n\n  const handleBlur = useCallback(() => {\n    setCustomValidity(undefined)\n    setSessionValue(undefined)\n  }, [])\n\n  useEffect(() => {\n    setCustomValidity(undefined)\n    setSessionValue(undefined)\n  }, [origin, value])\n\n  const resetButton: TextInputClearButtonProps = useMemo(() => ({icon: ResetIcon}), [])\n\n  return (\n    <>\n      <TextInput\n        clearButton={customValidity ? resetButton : undefined}\n        customValidity={customValidity}\n        fontSize={fontSize}\n        onBlur={handleBlur}\n        onClear={() => {\n          setCustomValidity(undefined)\n          setSessionValue(origin + value)\n        }}\n        onChange={handleChange}\n        onKeyDownCapture={handleKeyDown}\n        padding={padding}\n        prefix={prefix}\n        style={{zIndex: 1}}\n        radius={2}\n        ref={inputRef}\n        space={padding}\n        suffix={suffix}\n        value={sessionValue === undefined ? `${origin}${value}` : sessionValue}\n      />\n    </>\n  )\n}\n","import {CopyIcon, LaunchIcon} from '@sanity/icons'\nimport {createPreviewSecret} from '@sanity/preview-url-secret/create-secret'\nimport {\n  hasSecretSearchParams,\n  setSecretSearchParams,\n} from '@sanity/preview-url-secret/without-secret-search-params'\nimport {MenuItem, useToast} from '@sanity/ui'\nimport {useCallback, useState} from 'react'\nimport {useClient, useCurrentUser, useTranslation} from 'sanity'\n\nimport {API_VERSION} from '../constants'\nimport {presentationLocaleNamespace} from '../i18n'\nimport type {PreviewFrameProps} from './PreviewFrame'\n\n/** @internal */\nexport function ShareUrlMenuItems(\n  props: Pick<PreviewFrameProps, 'initialUrl' | 'openPopup'> & {\n    previewLocationOrigin: string\n    previewLocationRoute: string\n  },\n): React.ReactNode {\n  const {initialUrl, openPopup, previewLocationOrigin, previewLocationRoute} = props\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n\n  const handleOpenPopup = useCallback(\n    (event: React.MouseEvent<HTMLAnchorElement, MouseEvent>) => {\n      event.preventDefault()\n      openPopup(event.currentTarget.href)\n    },\n    [openPopup],\n  )\n\n  return (\n    <>\n      <CopyUrlMenuButton\n        initialUrl={initialUrl}\n        previewLocationOrigin={previewLocationOrigin}\n        previewLocationRoute={previewLocationRoute}\n      />\n      <MenuItem\n        icon={LaunchIcon}\n        text={t('share-url.menu-item.open.text')}\n        as=\"a\"\n        href={`${previewLocationOrigin}${previewLocationRoute}`}\n        // @ts-expect-error the `as=\"a\"` prop isn't enough to change the type of event.target from <div> to <a>\n        onClick={handleOpenPopup}\n        rel=\"opener\"\n        target=\"_blank\"\n      />\n    </>\n  )\n}\n\nfunction CopyUrlMenuButton(\n  props: Pick<PreviewFrameProps, 'initialUrl'> & {\n    previewLocationOrigin: string\n    previewLocationRoute: string\n  },\n) {\n  const {initialUrl, previewLocationOrigin, previewLocationRoute} = props\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n  const {push: pushToast} = useToast()\n  const client = useClient({apiVersion: API_VERSION})\n  const currentUser = useCurrentUser()\n  const [disabled, setDisabled] = useState(false)\n\n  return (\n    <MenuItem\n      disabled={disabled}\n      onClick={() => {\n        if (!navigator?.clipboard) {\n          pushToast({\n            closable: true,\n            status: 'error',\n            title: t('share-url.clipboard.status', {context: 'unsupported'}),\n          })\n          return false\n        }\n        setDisabled(true)\n\n        let id: string | undefined = undefined\n        const url = `${previewLocationOrigin}${previewLocationRoute}`\n        const onFinally = () => {\n          pushToast({\n            id,\n            closable: true,\n            status: 'success',\n            title: t('share-url.clipboard.status', {context: 'success'}),\n          })\n          setDisabled(false)\n        }\n        const onError = (error: Error) => {\n          pushToast({\n            closable: true,\n            status: 'error',\n            title: t('share-url.clipboard.status', {context: 'failed'}),\n            description: error.message || error.toString(),\n          })\n          setDisabled(false)\n        }\n        if (hasSecretSearchParams(initialUrl)) {\n          const resolvePreviewUrl = async () => {\n            id = pushToast({\n              closable: true,\n              title: t('share-url.clipboard.status', {context: 'copying'}),\n            })\n            const previewUrlSecret = await createPreviewSecret(\n              client,\n              '@sanity/presentation',\n              typeof window === 'undefined' ? '' : location.href,\n              currentUser?.id,\n            )\n\n            const newUrl = setSecretSearchParams(\n              initialUrl,\n              previewUrlSecret.secret,\n              previewLocationRoute,\n            )\n            return newUrl.toString()\n          }\n          if (typeof ClipboardItem !== 'undefined') {\n            const type = 'text/plain'\n            // Try to save to clipboard then save it in the state if worked\n            const item = new ClipboardItem({\n              [type]: resolvePreviewUrl().then((url) => new Blob([url], {type})),\n            })\n            navigator.clipboard.write([item]).then(onFinally).catch(onError)\n          } else {\n            resolvePreviewUrl()\n              .then((url) => navigator.clipboard.writeText(url))\n              .then(onFinally)\n              .catch(onError)\n          }\n        } else {\n          navigator.clipboard.writeText(url).then(onFinally).catch(onError)\n        }\n        return\n      }}\n      text={t('share-url.menu-item.copy.text')}\n      icon={CopyIcon}\n    />\n  )\n}\n","import type {ChannelStatus} from '@repo/channels'\nimport {\n  CheckmarkIcon,\n  ChevronDownIcon,\n  DesktopIcon,\n  EditIcon,\n  MobileDeviceIcon,\n  PanelLeftIcon,\n  PublishIcon,\n  RefreshIcon,\n  ShareIcon,\n} from '@sanity/icons'\nimport {withoutSecretSearchParams} from '@sanity/preview-url-secret/without-secret-search-params'\nimport {\n  Box,\n  Button,\n  type ButtonTone,\n  Card,\n  Code,\n  Flex,\n  Label,\n  Menu,\n  MenuButton,\n  MenuItem,\n  Spinner,\n  Stack,\n  Switch,\n  Text,\n  Tooltip,\n  TooltipDelayGroupProvider,\n  usePrefersReducedMotion,\n} from '@sanity/ui'\nimport {AnimatePresence, motion, MotionConfig} from 'framer-motion'\nimport {\n  type ComponentType,\n  createElement,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\nimport {Hotkeys, useTranslation} from 'sanity'\n\nimport {ErrorCard} from '../components/ErrorCard'\nimport {MAX_TIME_TO_OVERLAYS_CONNECTION} from '../constants'\nimport {presentationLocaleNamespace} from '../i18n'\nimport {\n  ACTION_IFRAME_LOADED,\n  ACTION_IFRAME_RELOAD,\n  type DispatchPresentationAction,\n  type PresentationState,\n} from '../reducers/presentationReducer'\nimport type {PresentationPerspective, PresentationViewport} from '../types'\nimport {usePresentationTool} from '../usePresentationTool'\nimport {IFrame} from './IFrame'\nimport {PreviewLocationInput} from './PreviewLocationInput'\nimport {ShareUrlMenuItems} from './ShareUrlMenuItems'\n\nconst MotionFlex = motion(Flex)\n\nconst PERSPECTIVE_TITLE_KEY: Record<PresentationPerspective, string> = {\n  previewDrafts: 'preview-frame.perspective.previewDrafts.title',\n  published: 'preview-frame.perspective.published.title',\n}\n\nconst PERSPECTIVE_TONES: Record<PresentationPerspective, ButtonTone> = {\n  previewDrafts: 'caution',\n  published: 'positive',\n}\n\nconst PERSPECTIVE_ICONS: Record<PresentationPerspective, ComponentType> = {\n  previewDrafts: EditIcon,\n  published: PublishIcon,\n}\n\nexport interface PreviewFrameProps extends Pick<PresentationState, 'iframe' | 'visualEditing'> {\n  dispatch: DispatchPresentationAction\n  initialUrl: URL\n  loadersConnection: ChannelStatus\n  navigatorEnabled: boolean\n  onPathChange: (nextPath: string) => void\n  onRefresh: (fallback: () => void) => void\n  openPopup: (url: string) => void\n  overlaysConnection: ChannelStatus\n  perspective: PresentationPerspective\n  previewUrl?: string\n  setPerspective: (perspective: 'previewDrafts' | 'published') => void\n  setViewport: (mode: 'desktop' | 'mobile') => void\n  targetOrigin: string\n  toggleNavigator?: () => void\n  toggleOverlay: () => void\n  viewport: PresentationViewport\n}\n\nexport const PreviewFrame = forwardRef<HTMLIFrameElement, PreviewFrameProps>(\n  function PreviewFrame(props, ref) {\n    const {\n      dispatch,\n      iframe,\n      initialUrl,\n      loadersConnection,\n      navigatorEnabled,\n      onPathChange,\n      onRefresh,\n      openPopup,\n      overlaysConnection,\n      perspective,\n      previewUrl,\n      setPerspective,\n      setViewport,\n      targetOrigin,\n      toggleNavigator,\n      toggleOverlay,\n      viewport,\n      visualEditing: {overlaysEnabled},\n    } = props\n\n    const {t} = useTranslation(presentationLocaleNamespace)\n    const {devMode} = usePresentationTool()\n    const prefersReducedMotion = usePrefersReducedMotion()\n\n    const toggleViewportSize = useCallback(\n      () => setViewport(viewport === 'desktop' ? 'mobile' : 'desktop'),\n      [setViewport, viewport],\n    )\n    const loading = iframe.status === 'loading' || iframe.status === 'reloading'\n    const [timedOut, setTimedOut] = useState(false)\n    const refreshing = iframe.status === 'refreshing'\n    const [somethingIsWrong, setSomethingIsWrong] = useState(false)\n    const iframeIsBusy = loading || refreshing || overlaysConnection === 'connecting'\n\n    const previewLocationOrigin = useMemo(() => {\n      return targetOrigin === location.origin ? '' : targetOrigin\n    }, [targetOrigin])\n\n    const handleRefresh = useCallback(() => {\n      onRefresh(() => {\n        if (typeof ref === 'function' || !ref?.current) {\n          return\n        }\n        dispatch({type: ACTION_IFRAME_RELOAD})\n        // Funky way to reload an iframe without CORS issues\n        // eslint-disable-next-line no-self-assign\n        // ref.current.src = ref.current.src\n        ref.current.src = `${targetOrigin}${previewUrl || '/'}`\n      })\n    }, [dispatch, onRefresh, previewUrl, targetOrigin, ref])\n    const handleRetry = useCallback(() => {\n      if (typeof ref === 'function' || !ref?.current) {\n        return\n      }\n\n      ref.current.src = initialUrl.toString()\n\n      dispatch({type: ACTION_IFRAME_RELOAD})\n    }, [dispatch, ref, initialUrl])\n    const handleContinueAnyway = useCallback(() => {\n      setContinueAnyway(true)\n    }, [])\n\n    const [continueAnyway, setContinueAnyway] = useState(false)\n    const [showOverlaysConnectionStatus, setShowOverlaysConnectionState] = useState(false)\n    useEffect(() => {\n      if (loading || refreshing) {\n        return\n      }\n\n      if (overlaysConnection === 'connecting' || overlaysConnection === 'reconnecting') {\n        const timeout = setTimeout(() => {\n          setShowOverlaysConnectionState(true)\n        }, 1000)\n        return () => clearTimeout(timeout)\n      }\n      return\n    }, [overlaysConnection, loading, refreshing])\n\n    useEffect(() => {\n      if (loading || refreshing || !showOverlaysConnectionStatus) {\n        return\n      }\n      if (overlaysConnection === 'connected') {\n        setSomethingIsWrong(false)\n        setShowOverlaysConnectionState(false)\n        setTimedOut(false)\n        setContinueAnyway(false)\n      }\n      if (overlaysConnection === 'connecting') {\n        const timeout = setTimeout(() => {\n          setTimedOut(true)\n          // eslint-disable-next-line no-console\n          console.error(\n            `Unable to connect to visual editing. Make sure you've setup '@sanity/visual-editing' correctly`,\n          )\n        }, MAX_TIME_TO_OVERLAYS_CONNECTION)\n        return () => clearTimeout(timeout)\n      }\n      if (overlaysConnection === 'reconnecting') {\n        const timeout = setTimeout(() => {\n          setTimedOut(true)\n          setSomethingIsWrong(true)\n        }, MAX_TIME_TO_OVERLAYS_CONNECTION)\n        return () => clearTimeout(timeout)\n      }\n      if (overlaysConnection === 'disconnected') {\n        setSomethingIsWrong(true)\n      }\n      return\n    }, [loading, overlaysConnection, refreshing, showOverlaysConnectionStatus])\n\n    const previewLocationRoute = useMemo(() => {\n      const previewURL = new URL(previewUrl || '/', targetOrigin)\n      const {pathname, search} = withoutSecretSearchParams(previewURL)\n\n      return `${pathname}${search}`\n    }, [previewUrl, targetOrigin])\n\n    const onIFrameLoad = useCallback(() => {\n      dispatch({type: ACTION_IFRAME_LOADED})\n    }, [dispatch])\n\n    /**\n     * Ensure that clicking outside of menus and dialogs will close as focus shifts to the iframe\n     */\n    useEffect(() => {\n      if (typeof ref === 'function' || !ref?.current) {\n        return\n      }\n      const instance = ref.current\n      function handleBlur() {\n        if (instance !== document.activeElement) {\n          return\n        }\n\n        instance.dispatchEvent(new MouseEvent('mousedown', {bubbles: true, cancelable: true}))\n      }\n      window.addEventListener('blur', handleBlur)\n      return () => {\n        window.removeEventListener('blur', handleBlur)\n      }\n    }, [ref])\n\n    const preventIframeInteraction = useMemo(() => {\n      return (\n        (loading || (overlaysConnection === 'connecting' && iframe.status !== 'refreshing')) &&\n        !continueAnyway\n      )\n    }, [continueAnyway, iframe.status, loading, overlaysConnection])\n\n    const iframeAnimations = useMemo(() => {\n      return [\n        preventIframeInteraction ? 'background' : 'active',\n        loading ? 'reloading' : 'idle',\n        viewport,\n        showOverlaysConnectionStatus && !continueAnyway ? 'timedOut' : '',\n      ]\n    }, [continueAnyway, loading, preventIframeInteraction, showOverlaysConnectionStatus, viewport])\n\n    return (\n      <MotionConfig transition={prefersReducedMotion ? {duration: 0} : undefined}>\n        <TooltipDelayGroupProvider delay={1000}>\n          <Card flex=\"none\" padding={2} shadow={1} style={{position: 'relative'}}>\n            <Flex align=\"center\" style={{minHeight: 0}}>\n              {toggleNavigator && (\n                <Box flex=\"none\" marginRight={1} padding={1}>\n                  <Tooltip\n                    animate\n                    content={\n                      <Text size={1}>{t('preview-frame.navigator.toggle-button.tooltip')}</Text>\n                    }\n                    fallbackPlacements={['bottom-start']}\n                    padding={2}\n                    placement=\"bottom\"\n                    portal\n                  >\n                    <Button\n                      aria-label={t('preview-frame.navigator.toggle-button.aria-label')}\n                      fontSize={1}\n                      icon={PanelLeftIcon}\n                      mode=\"bleed\"\n                      onClick={toggleNavigator}\n                      padding={2}\n                      selected={navigatorEnabled}\n                    />\n                  </Tooltip>\n                </Box>\n              )}\n\n              <Tooltip\n                animate\n                content={\n                  <Flex align=\"center\" style={{whiteSpace: 'nowrap'}}>\n                    <Box padding={1}>\n                      <Text size={1}>\n                        {t('preview-frame.overlay.toggle-button.tooltip', {\n                          context: overlaysEnabled ? 'disable' : 'enable',\n                        })}\n                      </Text>\n                    </Box>\n                    <Box paddingY={1}>\n                      <Hotkeys keys={['Alt']} style={{marginTop: -4, marginBottom: -4}} />\n                    </Box>\n                  </Flex>\n                }\n                fallbackPlacements={['bottom-start']}\n                padding={1}\n                placement=\"bottom\"\n                portal\n              >\n                <Card\n                  as=\"label\"\n                  flex=\"none\"\n                  marginRight={1}\n                  padding={3}\n                  style={{\n                    lineHeight: 0,\n                    borderRadius: 999,\n                    userSelect: 'none',\n                  }}\n                  tone={overlaysEnabled ? 'transparent' : undefined}\n                >\n                  <Flex align=\"center\" gap={3}>\n                    <div style={{margin: -4}}>\n                      <Switch\n                        checked={overlaysEnabled}\n                        onChange={toggleOverlay}\n                        disabled={iframe.status === 'loading' || overlaysConnection !== 'connected'}\n                      />\n                    </div>\n                    <Box>\n                      <Text muted={!overlaysEnabled} size={1} weight=\"medium\">\n                        {t('preview-frame.overlay.toggle-button.text')}\n                      </Text>\n                    </Box>\n                  </Flex>\n                </Card>\n              </Tooltip>\n\n              <Box flex={1} marginX={1}>\n                <PreviewLocationInput\n                  prefix={\n                    <Box padding={1}>\n                      <Tooltip\n                        animate\n                        content={\n                          <Text size={1}>\n                            {iframe.status === 'loaded'\n                              ? t('preview-frame.refresh-button.tooltip')\n                              : t('preview-frame.status', {context: iframe.status})}\n                          </Text>\n                        }\n                        fallbackPlacements={['bottom-start']}\n                        padding={2}\n                        placement=\"bottom\"\n                        portal\n                      >\n                        <Button\n                          aria-label={t('preview-frame.refresh-button.aria-label')}\n                          fontSize={1}\n                          icon={RefreshIcon}\n                          mode=\"bleed\"\n                          loading={iframe.status === 'reloading' || iframe.status === 'refreshing'}\n                          onClick={handleRefresh}\n                          padding={2}\n                        />\n                      </Tooltip>\n                    </Box>\n                  }\n                  onChange={onPathChange}\n                  origin={previewLocationOrigin}\n                  suffix={\n                    <Box padding={1}>\n                      <MenuButton\n                        button={\n                          <Button\n                            fontSize={1}\n                            iconRight={ShareIcon}\n                            mode=\"bleed\"\n                            padding={2}\n                            space={2}\n                          />\n                        }\n                        id=\"location-menu\"\n                        menu={\n                          <Menu>\n                            <ShareUrlMenuItems\n                              initialUrl={initialUrl}\n                              openPopup={openPopup}\n                              previewLocationOrigin={previewLocationOrigin}\n                              previewLocationRoute={previewLocationRoute}\n                            />\n                          </Menu>\n                        }\n                        popover={{\n                          animate: true,\n                          constrainSize: true,\n                          placement: 'bottom',\n                          portal: true,\n                        }}\n                      />\n                    </Box>\n                  }\n                  value={previewLocationRoute}\n                />\n              </Box>\n\n              <Flex align=\"center\" flex=\"none\" gap={1} padding={1}>\n                <MenuButton\n                  button={\n                    <Button\n                      fontSize={1}\n                      iconRight={ChevronDownIcon}\n                      mode=\"bleed\"\n                      padding={2}\n                      space={2}\n                      text={t(\n                        PERSPECTIVE_TITLE_KEY[\n                          loadersConnection === 'connected' ? perspective : 'previewDrafts'\n                        ],\n                      )}\n                      loading={loadersConnection === 'reconnecting' && iframe.status !== 'loaded'}\n                      disabled={loadersConnection !== 'connected'}\n                    />\n                  }\n                  id=\"perspective-menu\"\n                  menu={\n                    <Menu style={{maxWidth: 240}}>\n                      <MenuItem\n                        fontSize={1}\n                        onClick={() => setPerspective('previewDrafts')}\n                        padding={3}\n                        pressed={perspective === 'previewDrafts'}\n                        tone={PERSPECTIVE_TONES.previewDrafts}\n                      >\n                        <Flex align=\"flex-start\" gap={3}>\n                          <Box flex=\"none\">\n                            <Text size={1}>{createElement(PERSPECTIVE_ICONS.previewDrafts)}</Text>\n                          </Box>\n                          <Stack flex={1} space={2}>\n                            <Text size={1} weight=\"medium\">\n                              {t(PERSPECTIVE_TITLE_KEY['previewDrafts'])}\n                            </Text>\n                            <Text muted size={1}>\n                              {t('preview-frame.perspective.previewDrafts.text')}\n                            </Text>\n                          </Stack>\n                          <Box flex=\"none\">\n                            <Text\n                              muted\n                              size={1}\n                              style={{\n                                opacity: perspective === 'previewDrafts' ? 1 : 0,\n                              }}\n                            >\n                              <CheckmarkIcon />\n                            </Text>\n                          </Box>\n                        </Flex>\n                      </MenuItem>\n                      <MenuItem\n                        fontSize={1}\n                        onClick={() => setPerspective('published')}\n                        padding={3}\n                        pressed={perspective === 'published'}\n                        tone={PERSPECTIVE_TONES.published}\n                      >\n                        <Flex align=\"flex-start\" gap={3}>\n                          <Box flex=\"none\">\n                            <Text size={1}>{createElement(PERSPECTIVE_ICONS.published)}</Text>\n                          </Box>\n                          <Stack flex={1} space={2}>\n                            <Text size={1} weight=\"medium\">\n                              {t(PERSPECTIVE_TITLE_KEY['published'])}\n                            </Text>\n                            <Text muted size={1}>\n                              {t('preview-frame.perspective.published.text')}\n                            </Text>\n                          </Stack>\n                          <Box flex=\"none\">\n                            <Text\n                              muted\n                              size={1}\n                              style={{\n                                opacity: perspective === 'published' ? 1 : 0,\n                              }}\n                            >\n                              <CheckmarkIcon />\n                            </Text>\n                          </Box>\n                        </Flex>\n                      </MenuItem>\n                    </Menu>\n                  }\n                  popover={{\n                    animate: true,\n                    constrainSize: true,\n                    placement: 'bottom',\n                    portal: true,\n                  }}\n                />\n              </Flex>\n\n              <Flex align=\"center\" flex=\"none\" gap={1}>\n                <Tooltip\n                  animate\n                  content={\n                    <Text size={1}>\n                      {t('preview-frame.viewport-button.tooltip', {\n                        context: viewport === 'desktop' ? 'narrow' : 'full',\n                      })}\n                    </Text>\n                  }\n                  fallbackPlacements={['bottom-start']}\n                  padding={2}\n                  placement=\"bottom\"\n                  portal\n                >\n                  <Button\n                    aria-label={t('preview-frame.viewport-button.aria-label')}\n                    fontSize={1}\n                    icon={viewport === 'desktop' ? MobileDeviceIcon : DesktopIcon}\n                    mode=\"bleed\"\n                    onClick={toggleViewportSize}\n                    padding={2}\n                  />\n                </Tooltip>\n              </Flex>\n            </Flex>\n          </Card>\n\n          <Card flex={1} tone=\"transparent\">\n            <Flex\n              align=\"center\"\n              height=\"fill\"\n              justify=\"center\"\n              padding={viewport === 'desktop' ? 0 : 2}\n              sizing=\"border\"\n              style={{\n                position: 'relative',\n                cursor: iframeIsBusy ? 'wait' : undefined,\n              }}\n            >\n              <AnimatePresence>\n                {!somethingIsWrong &&\n                !loading &&\n                !refreshing &&\n                showOverlaysConnectionStatus &&\n                !continueAnyway ? (\n                  <MotionFlex\n                    initial=\"initial\"\n                    animate=\"animate\"\n                    exit=\"exit\"\n                    variants={spinnerVariants}\n                    justify=\"center\"\n                    align=\"center\"\n                    style={{\n                      inset: '0',\n                      position: 'absolute',\n                      backdropFilter: timedOut\n                        ? 'blur(16px) saturate(0.5) grayscale(0.5)'\n                        : 'blur(2px)',\n                      ['transition' as string]: 'backdrop-filter 0.2s ease-in-out',\n                      // @TODO Because of Safari we have to do this\n                      WebkitBackdropFilter: timedOut\n                        ? 'blur(16px) saturate(0.5) grayscale(0.5)'\n                        : 'blur(2px)',\n                      WebkitTransition: '-webkit-backdrop-filter 0.2s ease-in-out',\n                      zIndex: 1,\n                    }}\n                  >\n                    <Flex\n                      style={{...sizes[viewport]}}\n                      justify=\"center\"\n                      align=\"center\"\n                      direction=\"column\"\n                      gap={4}\n                    >\n                      {timedOut && (\n                        <Button\n                          disabled\n                          fontSize={1}\n                          mode=\"ghost\"\n                          text={t('preview-frame.continue-button.text')}\n                          style={{opacity: 0}}\n                        />\n                      )}\n                      <Card\n                        radius={2}\n                        tone={timedOut ? 'caution' : 'inherit'}\n                        padding={4}\n                        shadow={1}\n                      >\n                        <Flex justify=\"center\" align=\"center\" direction=\"column\" gap={4}>\n                          <Spinner muted />\n                          <Text muted size={1}>\n                            {timedOut\n                              ? t('preview-frame.status', {context: 'timeout'})\n                              : t('preview-frame.status', {context: 'connecting'})}\n                          </Text>\n                        </Flex>\n                      </Card>\n                      {timedOut && (\n                        <Button\n                          fontSize={1}\n                          // mode=\"ghost\"\n                          tone=\"critical\"\n                          onClick={handleContinueAnyway}\n                          text={t('preview-frame.continue-button.text')}\n                        />\n                      )}\n                    </Flex>\n                  </MotionFlex>\n                ) : (loading ||\n                    (overlaysConnection === 'connecting' && iframe.status !== 'refreshing')) &&\n                  !continueAnyway ? (\n                  <MotionFlex\n                    initial=\"initial\"\n                    animate=\"animate\"\n                    exit=\"exit\"\n                    variants={spinnerVariants}\n                    justify=\"center\"\n                    align=\"center\"\n                    style={{\n                      inset: '0',\n                      position: 'absolute',\n                      // boxShadow: '0 0 0 1px var(--card-shadow-outline-color)',\n                    }}\n                  >\n                    <Flex\n                      style={{...sizes[viewport]}}\n                      justify=\"center\"\n                      align=\"center\"\n                      direction=\"column\"\n                      gap={4}\n                    >\n                      <Spinner muted />\n                      <Text muted size={1}>\n                        {t('preview-frame.status', {context: 'loading'})}\n                      </Text>\n                    </Flex>\n                  </MotionFlex>\n                ) : somethingIsWrong && !continueAnyway ? (\n                  <MotionFlex\n                    initial=\"initial\"\n                    animate=\"animate\"\n                    exit=\"exit\"\n                    variants={errorVariants}\n                    justify=\"center\"\n                    align=\"center\"\n                    style={{\n                      background: 'var(--card-bg-color)',\n                      inset: '0',\n                      position: 'absolute',\n                      borderTop: '1px solid transparent',\n                      boxShadow: '0 0 0 1px var(--card-border-color)',\n                    }}\n                  >\n                    <ErrorCard\n                      flex={1}\n                      message={t('preview-frame.connection.error.text')}\n                      onRetry={handleRetry}\n                      onContinueAnyway={handleContinueAnyway}\n                    >\n                      {devMode && (\n                        <>\n                          {overlaysConnection !== 'connected' && (\n                            <Card padding={3} radius={2} tone=\"critical\">\n                              <Stack space={3}>\n                                <Label muted size={0}>\n                                  {t('preview-frame.overlay.connection-status.label')}\n                                </Label>\n                                <Code size={1}>\n                                  {t('channel.status', {context: overlaysConnection})}\n                                </Code>\n                              </Stack>\n                            </Card>\n                          )}\n\n                          {loadersConnection !== 'connected' && (\n                            <Card padding={3} radius={2} tone=\"critical\">\n                              <Stack space={3}>\n                                <Label muted size={0}>\n                                  {t('preview-frame.loader.connection-status.label')}\n                                </Label>\n                                <Code size={1}>\n                                  {t('channel.status', {context: loadersConnection})}\n                                </Code>\n                              </Stack>\n                            </Card>\n                          )}\n                        </>\n                      )}\n                    </ErrorCard>\n                  </MotionFlex>\n                ) : null}\n              </AnimatePresence>\n              <IFrame\n                animate={iframeAnimations}\n                initial={['background']}\n                onLoad={onIFrameLoad}\n                preventClick={preventIframeInteraction}\n                ref={ref}\n                src={initialUrl.toString()}\n                variants={iframeVariants}\n              />\n            </Flex>\n          </Card>\n        </TooltipDelayGroupProvider>\n      </MotionConfig>\n    )\n  },\n)\n\nconst sizes = {\n  desktop: {\n    width: '100%',\n    height: '100%',\n  },\n  mobile: {\n    width: 375,\n    height: 650,\n  },\n}\n\nconst spinnerVariants = {\n  initial: {opacity: 1},\n  animate: {opacity: [0, 0, 1]},\n  exit: {opacity: [1, 0, 0]},\n}\n\nconst errorVariants = {\n  initial: {opacity: 1},\n  animate: {opacity: [0, 0, 1]},\n  exit: {opacity: [1, 0, 0]},\n}\n\nconst iframeVariants = {\n  desktop: {\n    ...sizes.desktop,\n    boxShadow: '0 0 0 0px var(--card-border-color)',\n  },\n  mobile: {\n    ...sizes.mobile,\n    boxShadow: '0 0 0 1px var(--card-border-color)',\n  },\n  background: {\n    opacity: 0,\n    scale: 1,\n  },\n  idle: {\n    scale: 1,\n  },\n  reloading: {\n    scale: [1, 1, 1, 0.98],\n  },\n  active: {\n    opacity: [0, 0, 1],\n    scale: 1,\n  },\n  timedOut: {\n    opacity: [0, 0, 1],\n  },\n}\n","import type {ClientPerspective} from '@sanity/client'\nimport isEqual from 'fast-deep-equal'\nimport {type MutableRefObject, useCallback, useMemo, useRef, useState} from 'react'\n\nimport type {FrameState, PresentationPerspective} from './types'\n\nexport type DocumentOnPage = {\n  _id: string\n  _type: string\n}\n\ntype DocumentCache = Record<string, DocumentOnPage>\ntype KeyedDocumentCache = Record<string, DocumentCache>\n\nlet warnedAboutCrossDatasetReference = false\n\nexport function useDocumentsOnPage(\n  perspective: PresentationPerspective,\n  frameStateRef: MutableRefObject<FrameState>,\n): [\n  DocumentOnPage[],\n  (key: string, perspective: PresentationPerspective, state: DocumentOnPage[]) => void,\n] {\n  if (perspective !== 'published' && perspective !== 'previewDrafts') {\n    throw new Error(`Invalid perspective: ${perspective}`)\n  }\n\n  const [published, setPublished] = useState<KeyedDocumentCache>({})\n  const [previewDrafts, setPreviewDrafts] = useState<KeyedDocumentCache>({})\n\n  // Used to compare the frame url with its value when the cache was last updated\n  // If the url has changed, the entire cache is replaced\n  const urlRef = useRef<string | undefined>('')\n\n  const setDocumentsOnPage = useCallback(\n    (key: string, perspective: ClientPerspective, sourceDocuments: DocumentOnPage[] = []) => {\n      const documents = sourceDocuments.filter((sourceDocument) => {\n        if ('_projectId' in sourceDocument && sourceDocument._projectId) {\n          // @TODO Handle cross dataset references\n          if (!warnedAboutCrossDatasetReference) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              'Cross dataset references are not supported yet, ignoring source document',\n              sourceDocument,\n            )\n            warnedAboutCrossDatasetReference = true\n          }\n          return false\n        }\n        return sourceDocument\n      })\n\n      const setCache = perspective === 'published' ? setPublished : setPreviewDrafts\n\n      setCache((cache) => {\n        // Create the `next` documents, dedupe by `_id`\n        const next: Record<string, DocumentOnPage> = {}\n        for (const document of documents) {\n          next[document._id] = document\n        }\n\n        // If the frame url has changed, replace the entire cache with the next documents\n        if (urlRef.current !== frameStateRef.current.url) {\n          urlRef.current = frameStateRef.current.url\n          return {[key]: next}\n        }\n\n        // If the keyed cache has changed, return the entire cache and replace the keyed part\n        const prev = cache[key]\n        if (!isEqual(prev, next)) {\n          return {...cache, [key]: next}\n        }\n\n        // Otherwise return the entire cache as is\n        return cache\n      })\n    },\n    [frameStateRef],\n  )\n\n  const documentsOnPage = useMemo(() => {\n    const keyedCache = perspective === 'published' ? published : previewDrafts\n    const uniqueDocuments = Object.values(keyedCache).reduce((acc, cache) => {\n      Object.values(cache).forEach((doc) => {\n        acc[doc._id] = doc\n      })\n      return acc\n    }, {})\n\n    return Object.values(uniqueDocuments)\n  }, [perspective, previewDrafts, published])\n\n  return [documentsOnPage, setDocumentsOnPage]\n}\n","import type {ResponseQueryOptions} from '@sanity/client'\nimport {match, type Path} from 'path-to-regexp'\nimport {useCallback, useEffect, useMemo, useRef, useState} from 'react'\nimport {useClient} from 'sanity'\nimport {type RouterState, useRouter} from 'sanity/router'\n\nimport {API_VERSION} from './constants'\nimport type {\n  DocumentResolver,\n  DocumentResolverContext,\n  MainDocument,\n  MainDocumentState,\n  PresentationNavigate,\n  PreviewUrlOption,\n} from './types'\n\n// Helper function to \"unwrap\" a result when it is either explicitly provided or\n// returned as the result of a passed function\nfunction fnOrObj<T, U>(arg: T | ((ctx: U) => T), context: U): T {\n  return arg instanceof Function ? arg(context) : arg\n}\n\nfunction getQueryFromResult(\n  resolver: DocumentResolver,\n  context: DocumentResolverContext,\n): string | undefined {\n  if (resolver.resolve) {\n    const filter = resolver.resolve(context)?.filter\n    return filter ? `*[${filter}][0]{_id, _type}` : undefined\n  }\n\n  if ('type' in resolver) {\n    return `*[_type == \"${resolver.type}\"][0]{_id, _type}`\n  }\n\n  return `*[${fnOrObj(resolver.filter, context)}][0]{_id, _type}`\n}\n\nfunction getParamsFromResult(\n  resolver: DocumentResolver,\n  context: DocumentResolverContext,\n): Record<string, string> {\n  if (resolver.resolve) {\n    return resolver.resolve(context)?.params ?? context.params\n  }\n\n  if ('type' in resolver) {\n    return {}\n  }\n\n  return fnOrObj(resolver.params, context) ?? context.params\n}\n\nexport function getRouteContext(route: Path, url: URL): DocumentResolverContext | undefined {\n  const routes = Array.isArray(route) ? route : [route]\n\n  for (route of routes) {\n    let origin: DocumentResolverContext['origin'] = undefined\n    let path = route\n\n    // Handle absolute URLs\n    if (typeof route === 'string') {\n      try {\n        const absolute = new URL(route)\n        origin = absolute.origin\n        path = absolute.pathname\n      } catch {\n        // Ignore, as we assume a relative path\n      }\n    }\n\n    // If an origin has been explicitly provided, check that it matches\n    if (origin && url.origin !== origin) continue\n\n    try {\n      const matcher = match<Record<string, string>>(path, {decode: decodeURIComponent})\n      const result = matcher(url.pathname)\n      if (result) {\n        const {params, path} = result\n        return {origin, params, path}\n      }\n    } catch (e) {\n      throw new Error(`\"${route}\" is not a valid route pattern`)\n    }\n  }\n  return undefined\n}\n\nexport function useMainDocument(props: {\n  navigate?: PresentationNavigate\n  navigationHistory: RouterState[]\n  path?: string\n  previewUrl?: PreviewUrlOption\n  resolvers?: DocumentResolver[]\n}): MainDocumentState | undefined {\n  const {navigate, navigationHistory, path, previewUrl, resolvers = []} = props\n  const {state: routerState} = useRouter()\n  const client = useClient({apiVersion: API_VERSION})\n\n  const [mainDocumentState, setMainDocumentState] = useState<MainDocumentState | undefined>(\n    undefined,\n  )\n  const mainDocumentIdRef = useRef<string | undefined>(undefined)\n\n  const url = useMemo(() => {\n    const relativeUrl =\n      path || routerState._searchParams?.find(([key]) => key === 'preview')?.[1] || ''\n\n    const base =\n      typeof previewUrl === 'string'\n        ? previewUrl\n        : typeof previewUrl === 'object'\n          ? previewUrl?.origin || location.origin\n          : location.origin\n\n    return new URL(relativeUrl, base)\n  }, [path, previewUrl, routerState._searchParams])\n\n  const clearState = useCallback(() => {\n    setMainDocumentState(undefined)\n    mainDocumentIdRef.current = undefined\n  }, [])\n\n  useEffect(() => {\n    if (resolvers.length && url) {\n      let result:\n        | {\n            context: DocumentResolverContext\n            resolver: DocumentResolver\n          }\n        | undefined\n\n      for (const resolver of resolvers) {\n        const context = getRouteContext(resolver.route, url)\n        if (context) {\n          result = {context, resolver}\n          break\n        }\n      }\n\n      if (result) {\n        const query = getQueryFromResult(result.resolver, result.context)\n        const params = getParamsFromResult(result.resolver, result.context)\n\n        if (query) {\n          const controller = new AbortController()\n          const options: ResponseQueryOptions = {\n            perspective: 'previewDrafts',\n            signal: controller.signal,\n          }\n\n          client\n            .fetch<MainDocument | undefined>(query, params, options)\n            .then((doc) => {\n              if (!doc || mainDocumentIdRef.current !== doc._id) {\n                setMainDocumentState({\n                  document: doc,\n                  path: url.pathname,\n                })\n                mainDocumentIdRef.current = doc?._id\n\n                // We only want to force a navigation to the main document if\n                // the path changed but the document ID did not. An explicit\n                // document navigation should take precedence over displaying\n                // the main document. We determine if an explicit document\n                // navigation has occured by comparing the IDs of the last two\n                // resultant navigation states.\n                if (navigationHistory.at(-1)?.['id'] === navigationHistory.at(-2)?.['id']) {\n                  navigate?.({\n                    id: doc?._id,\n                    type: doc?._type,\n                  })\n                }\n              }\n            })\n            .catch((e) => {\n              if (e instanceof Error && e.name === 'AbortError') return\n              setMainDocumentState({document: undefined, path: url.pathname})\n              mainDocumentIdRef.current = undefined\n            })\n          return () => {\n            controller.abort()\n          }\n        }\n      }\n    }\n    clearState()\n    return undefined\n  }, [client, clearState, navigate, navigationHistory, resolvers, url])\n\n  return mainDocumentState\n}\n","import {urlStringToPath} from '@repo/visual-editing-helpers'\nimport {studioPath} from '@sanity/client/csm'\n\nimport type {PresentationStateParams} from '../types'\n\nexport function parseId(rawId: string | undefined): string | undefined {\n  if (rawId === undefined) {\n    return undefined\n  }\n\n  const segments = decodeURIComponent(rawId)?.split('.')\n\n  if (segments[0] === 'drafts') {\n    segments.shift()\n  }\n\n  return segments.join('.')\n}\n\nexport function parsePath(rawPath: string | undefined): string | undefined {\n  if (rawPath === undefined) {\n    return undefined\n  }\n\n  return studioPath.toString(urlStringToPath(decodeURIComponent(rawPath)))\n}\n\nexport function parseRouterState(state: PresentationStateParams): PresentationStateParams {\n  return {\n    id: parseId(state.id),\n    path: parsePath(state.path),\n    type: state.type,\n  }\n}\n","import {type MutableRefObject, useCallback, useEffect, useMemo, useRef, useState} from 'react'\nimport type {RouterContextValue, RouterState, SearchParam} from 'sanity/router'\n\nimport {getPublishedId} from './internals'\nimport {parseRouterState} from './lib/parse'\nimport type {\n  CombinedSearchParams,\n  FrameState,\n  PresentationNavigate,\n  PresentationParams,\n  PresentationSearchParams,\n  PresentationStateParams,\n  StructureDocumentPaneParams,\n} from './types'\n\nfunction pruneObject<T extends RouterState | PresentationParams>(obj: T): T {\n  return Object.fromEntries(\n    Object.entries(obj).filter(\n      ([, value]) => value !== undefined && value !== '' && value !== null,\n    ),\n  ) as T\n}\n\nexport function useParams({\n  initialPreviewUrl,\n  routerNavigate,\n  routerState,\n  routerSearchParams,\n  frameStateRef,\n}: {\n  initialPreviewUrl: URL\n  routerNavigate: RouterContextValue['navigate']\n  routerState: RouterState & PresentationStateParams\n  routerSearchParams: {\n    [k: string]: string\n  }\n  frameStateRef: MutableRefObject<FrameState>\n}): {\n  navigate: PresentationNavigate\n  navigationHistory: RouterState[]\n  params: PresentationParams\n  searchParams: PresentationSearchParams\n  structureParams: StructureDocumentPaneParams\n} {\n  const params = useMemo<PresentationParams>(() => {\n    const {id, path, type} = parseRouterState(routerState)\n\n    return {\n      id,\n      type,\n      path,\n      preview:\n        routerSearchParams['preview'] || `${initialPreviewUrl.pathname}${initialPreviewUrl.search}`,\n      perspective: routerSearchParams['perspective'],\n      viewport: routerSearchParams['viewport'],\n      inspect: routerSearchParams['inspect'],\n      rev: routerSearchParams['rev'],\n      prefersLatestPublished: routerSearchParams['prefersLatestPublished'],\n      since: routerSearchParams['since'],\n      template: routerSearchParams['template'],\n      templateParams: routerSearchParams['templateParams'],\n      view: routerSearchParams['view'],\n      // assist\n      pathKey: routerSearchParams['pathKey'],\n      instruction: routerSearchParams['instruction'],\n      // comments\n      comment: routerSearchParams['comment'],\n    }\n  }, [routerState, routerSearchParams, initialPreviewUrl])\n\n  const structureParams = useMemo<StructureDocumentPaneParams>(() => {\n    const pruned = pruneObject({\n      inspect: params.inspect,\n      path: params.path,\n      rev: params.rev,\n      prefersLatestPublished: params.prefersLatestPublished,\n      since: params.since,\n      template: params.template,\n      templateParams: params.templateParams,\n      view: params.view,\n      // assist\n      pathKey: params.pathKey,\n      instruction: params.instruction,\n      // comments\n      comment: params.comment,\n    })\n    return pruned\n  }, [\n    params.comment,\n    params.inspect,\n    params.instruction,\n    params.path,\n    params.pathKey,\n    params.prefersLatestPublished,\n    params.rev,\n    params.since,\n    params.template,\n    params.templateParams,\n    params.view,\n  ])\n\n  const searchParams = useMemo<PresentationSearchParams>(() => {\n    const pruned = pruneObject({\n      perspective: params.perspective,\n      preview: params.preview,\n      viewport: params.viewport,\n    })\n    return pruned\n  }, [params.perspective, params.preview, params.viewport])\n\n  const routerStateRef = useRef(routerState)\n\n  useEffect(() => {\n    routerStateRef.current = routerState\n  }, [routerState])\n\n  const [navigationHistory, setNavigationHistory] = useState<RouterState[]>([routerState])\n\n  const navigate = useCallback<PresentationNavigate>(\n    (nextState, nextSearchState = {}, forceReplace) => {\n      // Force navigation to use published IDs only\n      if (nextState.id) nextState.id = getPublishedId(nextState.id)\n\n      // Extract type, id and path as 'routerState'\n      const {_searchParams: routerSearchParams, ...routerState} = routerStateRef.current\n\n      // Convert array of search params to an object\n      const routerSearchState = (routerSearchParams || []).reduce(\n        (acc, [key, value]) => ((acc[key as keyof CombinedSearchParams] = value), acc),\n        {} as CombinedSearchParams,\n      )\n\n      // Merge routerState and incoming state\n      const state: RouterState = pruneObject({\n        ...routerState,\n        ...nextState,\n      })\n\n      // Merge routerSearchState and incoming searchState\n      const searchState = pruneObject({\n        ...routerSearchState,\n        ...nextSearchState,\n      })\n\n      // If the document has changed, clear the template and templateParams\n      if (routerState.id !== state['id']) {\n        delete searchState.template\n        delete searchState.templateParams\n      }\n\n      state._searchParams = Object.entries(searchState).reduce(\n        (acc, [key, value]) => [...acc, [key, value]],\n        [] as SearchParam[],\n      )\n\n      const replace = forceReplace ?? searchState.preview === frameStateRef.current.url\n\n      setNavigationHistory((prev) => [...prev, state])\n      routerNavigate(state, {replace})\n    },\n    [routerNavigate, frameStateRef],\n  )\n\n  return {\n    navigate,\n    navigationHistory,\n    params,\n    searchParams,\n    structureParams,\n  }\n}\n","import {createPreviewSecret} from '@sanity/preview-url-secret/create-secret'\nimport {definePreviewUrl} from '@sanity/preview-url-secret/define-preview-url'\nimport {startTransition, useEffect, useMemo, useRef, useState} from 'react'\nimport {type SanityClient, useClient, useCurrentUser} from 'sanity'\nimport {suspend} from 'suspend-react'\n\nimport {API_VERSION} from './constants'\nimport {useActiveWorkspace} from './internals'\nimport type {PreviewUrlOption} from './types'\n\nexport function usePreviewUrl(\n  previewUrl: PreviewUrlOption,\n  toolName: string,\n  previewSearchParam: string | null,\n): URL {\n  const client = useClient({apiVersion: API_VERSION})\n  const workspace = useActiveWorkspace()\n  const basePath = workspace?.activeWorkspace?.basePath || '/'\n  const workspaceName = workspace?.activeWorkspace?.name || 'default'\n  const deps = useSuspendCacheKeys(toolName, basePath, workspaceName, previewSearchParam)\n  const previewUrlSecret = usePreviewUrlSecret(\n    typeof previewUrl === 'object' || typeof previewUrl === 'function',\n    deps,\n  )\n\n  return suspend(async () => {\n    if (typeof previewUrl === 'string') {\n      const resolvedUrl = new URL(previewUrl, location.origin)\n      let resultUrl = resolvedUrl\n      try {\n        if (previewSearchParam) {\n          const restoredUrl = new URL(previewSearchParam, resolvedUrl)\n          if (restoredUrl.origin === resolvedUrl.origin) {\n            resultUrl = restoredUrl\n          }\n        } else if (document.referrer) {\n          const referrerUrl = new URL(document.referrer)\n          if (referrerUrl.origin === resolvedUrl.origin) {\n            resultUrl = referrerUrl\n          }\n        }\n      } catch {\n        // ignore\n      }\n      // Prevent infinite recursion\n      if (\n        location.origin === resultUrl.origin &&\n        (resultUrl.pathname.startsWith(`${basePath}/`) || resultUrl.pathname === basePath)\n      ) {\n        return resolvedUrl\n      }\n      return resultUrl\n    }\n    const resolvePreviewUrl =\n      typeof previewUrl === 'object' ? definePreviewUrl<SanityClient>(previewUrl) : previewUrl\n    const resolvedUrl = await resolvePreviewUrl({\n      client,\n      previewUrlSecret: previewUrlSecret!,\n      previewSearchParam,\n      referrer: typeof document === 'undefined' ? null : document.referrer,\n      studioBasePath: basePath,\n    })\n    return new URL(resolvedUrl, location.origin)\n  }, [...deps, previewUrlSecret]) satisfies URL\n}\n\n// https://github.com/pmndrs/suspend-react?tab=readme-ov-file#making-cache-keys-unique\nconst resolveUUID = Symbol()\n\nfunction useSuspendCacheKeys(\n  toolName: string,\n  basePath: string,\n  workspaceName: string,\n  previewSearchParam: string | null,\n) {\n  // Allow busting the cache when the Presentation Tool is reloaded, without causing it to suspend on every render that changes the `preview` parameter\n  const [cachedPreviewSearchParam, setCachedPreviewSearchParam] = useState(\n    () => previewSearchParam || '',\n  )\n  const timeoutRef = useRef(0)\n  useEffect(() => {\n    if (cachedPreviewSearchParam && previewSearchParam) {\n      // Handle resets, like when the Presentation Tool is clicked in the navbar\n      window.clearTimeout(timeoutRef.current)\n      return () => {\n        timeoutRef.current = window.setTimeout(() => {\n          setCachedPreviewSearchParam('')\n        }, 100)\n      }\n    }\n    return\n  }, [cachedPreviewSearchParam, previewSearchParam])\n\n  const currentUser = useCurrentUser()\n  return useMemo(\n    () => [\n      // Cache based on a few specific conditions\n      '@sanity/presentation',\n      basePath,\n      workspaceName,\n      toolName,\n      currentUser?.id,\n      resolveUUID,\n      cachedPreviewSearchParam,\n    ],\n    [basePath, currentUser?.id, toolName, workspaceName, cachedPreviewSearchParam],\n  )\n}\n\nfunction usePreviewUrlSecret(enabled: boolean, deps: (string | symbol | undefined)[]) {\n  const client = useClient({apiVersion: API_VERSION})\n  const currentUser = useCurrentUser()\n  const [secretLastExpiredAt, setSecretLastExpiredAt] = useState<string>('')\n\n  const previewUrlSecret = enabled\n    ? suspend(async () => {\n        return await createPreviewSecret(\n          client,\n          '@sanity/presentation',\n          typeof window === 'undefined' ? '' : location.href,\n          currentUser?.id,\n        )\n      }, [...deps, secretLastExpiredAt])\n    : null\n\n  useEffect(() => {\n    if (!previewUrlSecret) return\n    const timeout = setTimeout(() => {\n      startTransition(() => setSecretLastExpiredAt(previewUrlSecret.expiresAt.toString()))\n    }, previewUrlSecret.expiresAt.getTime() - Date.now())\n    return () => clearTimeout(timeout)\n  }, [previewUrlSecret])\n\n  return previewUrlSecret?.secret || null\n}\n","import {type ChannelsController, type ChannelStatus, createChannelsController} from '@repo/channels'\nimport {\n  getQueryCacheKey,\n  isAltKey,\n  isHotkey,\n  type LoaderMsg,\n  type OverlayMsg,\n  type PresentationMsg,\n  type PreviewKitMsg,\n  type VisualEditingConnectionIds,\n  type VisualEditingMsg,\n} from '@repo/visual-editing-helpers'\nimport {studioPath} from '@sanity/client/csm'\nimport {BoundaryElementProvider, Flex} from '@sanity/ui'\nimport {\n  lazy,\n  type ReactElement,\n  Suspense,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from 'react'\nimport {type Path, type SanityDocument, type Tool, useDataset, useProjectId} from 'sanity'\nimport {type RouterContextValue, useRouter} from 'sanity/router'\nimport {styled} from 'styled-components'\n\nimport {\n  COMMENTS_INSPECTOR_NAME,\n  DEFAULT_TOOL_NAME,\n  EDIT_INTENT_MODE,\n  MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL,\n} from './constants'\nimport {type CommentIntentGetter, useUnique, useWorkspace} from './internals'\nimport {debounce} from './lib/debounce'\nimport {Panel} from './panels/Panel'\nimport {Panels} from './panels/Panels'\nimport {PresentationContent} from './PresentationContent'\nimport {PresentationNavigateProvider} from './PresentationNavigateProvider'\nimport {usePresentationNavigator} from './PresentationNavigator'\nimport {PresentationParamsProvider} from './PresentationParamsProvider'\nimport {PresentationProvider} from './PresentationProvider'\nimport {PreviewFrame} from './preview/PreviewFrame'\nimport {\n  ACTION_IFRAME_LOADED,\n  ACTION_IFRAME_REFRESH,\n  ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE,\n  presentationReducer,\n  presentationReducerInit,\n} from './reducers/presentationReducer'\nimport type {\n  FrameState,\n  LiveQueriesState,\n  LiveQueriesStateValue,\n  PresentationNavigate,\n  PresentationPerspective,\n  PresentationPluginOptions,\n  PresentationStateParams,\n  PresentationViewport,\n  StructureDocumentPaneParams,\n} from './types'\nimport {useDocumentsOnPage} from './useDocumentsOnPage'\nimport {useMainDocument} from './useMainDocument'\nimport {useParams} from './useParams'\nimport {usePreviewUrl} from './usePreviewUrl'\n\nconst LoaderQueries = lazy(() => import('./loader/LoaderQueries'))\nconst PostMessageRefreshMutations = lazy(() => import('./editor/PostMessageRefreshMutations'))\n\nconst Container = styled(Flex)`\n  overflow-x: auto;\n`\n\nexport default function PresentationTool(props: {\n  tool: Tool<PresentationPluginOptions>\n}): ReactElement {\n  const {previewUrl: _previewUrl, components} = props.tool.options ?? {}\n  const name = props.tool.name || DEFAULT_TOOL_NAME\n  const {unstable_navigator} = components || {}\n\n  const {navigate: routerNavigate, state: routerState} = useRouter() as RouterContextValue & {\n    state: PresentationStateParams\n  }\n  const routerSearchParams = useUnique(Object.fromEntries(routerState._searchParams || []))\n\n  const initialPreviewUrl = usePreviewUrl(\n    _previewUrl || '/',\n    name,\n    routerSearchParams['preview'] || null,\n  )\n\n  const [devMode] = useState(() => {\n    const option = props.tool.options?.devMode\n\n    if (typeof option === 'function') return option()\n    if (typeof option === 'boolean') return option\n\n    return typeof window !== 'undefined' && window.location.hostname === 'localhost'\n  })\n\n  const targetOrigin = useMemo(() => {\n    return initialPreviewUrl.origin\n  }, [initialPreviewUrl.origin])\n\n  const iframeRef = useRef<HTMLIFrameElement>(null)\n\n  const [channel, setChannel] =\n    useState<ChannelsController<VisualEditingConnectionIds, PresentationMsg | LoaderMsg>>()\n\n  const [liveQueries, setLiveQueries] = useState<LiveQueriesState>({})\n\n  const frameStateRef = useRef<FrameState>({\n    title: undefined,\n    url: undefined,\n  })\n\n  const {\n    navigate: _navigate,\n    navigationHistory,\n    params,\n    searchParams,\n    structureParams,\n  } = useParams({\n    initialPreviewUrl,\n    routerNavigate,\n    routerState,\n    routerSearchParams,\n    frameStateRef,\n  })\n\n  // Most navigation events should be debounced, so use this unless explicitly needed\n  const navigate = useMemo(() => debounce<PresentationNavigate>(_navigate, 50), [_navigate])\n\n  const [state, dispatch] = useReducer(presentationReducer, {}, presentationReducerInit)\n\n  const perspective = useMemo(\n    () => (params.perspective ? 'published' : 'previewDrafts'),\n    [params.perspective],\n  )\n\n  const viewport = useMemo(() => (params.viewport ? 'mobile' : 'desktop'), [params.viewport])\n\n  const [documentsOnPage, setDocumentsOnPage] = useDocumentsOnPage(perspective, frameStateRef)\n\n  const projectId = useProjectId()\n  const dataset = useDataset()\n\n  const mainDocumentState = useMainDocument({\n    // Prevent flash of content by using immediate navigation\n    navigate: _navigate,\n    navigationHistory,\n    path: params.preview,\n    previewUrl: props.tool.options?.previewUrl,\n    resolvers: props.tool.options?.resolve?.mainDocuments,\n  })\n\n  const [overlaysConnection, setOverlaysConnection] = useState<ChannelStatus>('connecting')\n  const [loadersConnection, setLoadersConnection] = useState<ChannelStatus>('connecting')\n  const [previewKitConnection, setPreviewKitConnection] = useState<ChannelStatus>('connecting')\n\n  const [popups] = useState<Set<Window>>(() => new Set())\n  const handleOpenPopup = useCallback(\n    (url: string) => {\n      const source = window.open(url, '_blank')\n      if (source) {\n        popups.add(source)\n      }\n    },\n    [popups],\n  )\n\n  useEffect(() => {\n    if (popups.size && channel) {\n      // loop popups and call channel.addSource\n      for (const source of popups) {\n        if (source && 'closed' in source && !source.closed) {\n          channel.addSource(source)\n        }\n      }\n    }\n  }, [channel, popups, popups.size])\n\n  // This workaround can be removed once the need to set prefersLatestPublished is no longer there\n  const perspectiveRef = useRef(perspective)\n  useEffect(() => {\n    perspectiveRef.current = perspective\n  }, [perspective])\n\n  useEffect(() => {\n    const target = iframeRef.current?.contentWindow\n\n    if (!target) return\n\n    const nextChannel = createChannelsController<\n      VisualEditingConnectionIds,\n      PresentationMsg | LoaderMsg,\n      LoaderMsg | OverlayMsg | VisualEditingMsg | PreviewKitMsg\n    >({\n      id: 'presentation',\n      target,\n      targetOrigin,\n      connectTo: [\n        {\n          id: 'overlays',\n          heartbeat: true,\n          onStatusUpdate: setOverlaysConnection,\n          onEvent(type, data) {\n            if ((type === 'visual-editing/focus' || type === 'overlay/focus') && 'id' in data) {\n              navigate(\n                {\n                  type: data.type,\n                  id: data.id,\n                  path: data.path,\n                },\n                {\n                  prefersLatestPublished:\n                    'isDraft' in data || perspectiveRef.current === 'previewDrafts'\n                      ? undefined\n                      : 'true',\n                },\n              )\n            } else if (type === 'visual-editing/navigate' || type === 'overlay/navigate') {\n              const {title, url} = data\n              if (frameStateRef.current.url !== url) {\n                navigate({}, {preview: url})\n              }\n              frameStateRef.current = {title, url}\n            } else if (type === 'visual-editing/meta') {\n              frameStateRef.current.title = data.title\n            } else if (type === 'visual-editing/toggle' || type === 'overlay/toggle') {\n              dispatch({\n                type: ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE,\n                enabled: data.enabled,\n              })\n            } else if (type === 'visual-editing/documents') {\n              setDocumentsOnPage(\n                'visual-editing',\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                data.perspective as unknown as any,\n                data.documents,\n              )\n            } else if (type === 'visual-editing/refreshing' && data.source === 'manual') {\n              clearTimeout(refreshRef.current)\n            } else if (type === 'visual-editing/refreshing' && data.source === 'mutation') {\n              dispatch({type: ACTION_IFRAME_REFRESH})\n            } else if (type === 'visual-editing/refreshed') {\n              dispatch({type: ACTION_IFRAME_LOADED})\n            }\n          },\n        },\n        {\n          id: 'loaders',\n          heartbeat: true,\n          onStatusUpdate: setLoadersConnection,\n          onEvent(type, data) {\n            if (\n              type === 'loader/documents' &&\n              data.projectId === projectId &&\n              data.dataset === dataset\n            ) {\n              setDocumentsOnPage(\n                'loaders',\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                data.perspective as unknown as any,\n                data.documents,\n              )\n            } else if (\n              type === 'loader/query-listen' &&\n              data.projectId === projectId &&\n              data.dataset === dataset\n            ) {\n              if (\n                typeof data.heartbeat === 'number' &&\n                data.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL\n              ) {\n                throw new Error(\n                  `Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`,\n                )\n              }\n              setLiveQueries((prev) => ({\n                ...prev,\n                [getQueryCacheKey(data.query, data.params)]: {\n                  perspective: data.perspective,\n                  query: data.query,\n                  params: data.params,\n                  receivedAt: Date.now(),\n                  heartbeat: data.heartbeat ?? false,\n                } satisfies LiveQueriesStateValue,\n              }))\n            }\n          },\n        },\n        {\n          id: 'preview-kit',\n          heartbeat: true,\n          onStatusUpdate: setPreviewKitConnection,\n          onEvent(type, data) {\n            if (\n              type === 'preview-kit/documents' &&\n              data.projectId === projectId &&\n              data.dataset === dataset\n            ) {\n              setDocumentsOnPage(\n                'preview-kit',\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                data.perspective as unknown as any,\n                data.documents,\n              )\n            }\n          },\n        },\n      ],\n    })\n    setChannel(nextChannel)\n\n    return () => {\n      nextChannel.destroy()\n      setChannel(undefined)\n    }\n  }, [dataset, projectId, setDocumentsOnPage, navigate, targetOrigin])\n\n  useEffect(() => {\n    const interval = setInterval(\n      () =>\n        setLiveQueries((liveQueries) => {\n          if (Object.keys(liveQueries).length < 1) {\n            return liveQueries\n          }\n\n          const now = Date.now()\n          const hasAnyExpired = Object.values(liveQueries).some(\n            (liveQuery) =>\n              liveQuery.heartbeat !== false && now > liveQuery.receivedAt + liveQuery.heartbeat,\n          )\n          if (!hasAnyExpired) {\n            return liveQueries\n          }\n          const next = {} as LiveQueriesState\n          for (const [key, value] of Object.entries(liveQueries)) {\n            if (value.heartbeat !== false && now > value.receivedAt + value.heartbeat) {\n              continue\n            }\n            next[key] = value\n          }\n          return next\n        }),\n      MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL,\n    )\n    return () => clearInterval(interval)\n  }, [])\n\n  const handleFocusPath = useCallback(\n    (nextPath: Path) => {\n      // Don’t need to explicitly set the id here because it was either already set via postMessage or is the same if navigating in the document pane\n      navigate({path: studioPath.toString(nextPath)}, {}, true)\n    },\n    [navigate],\n  )\n\n  const handlePreviewPath = useCallback(\n    (nextPath: string) => {\n      const url = new URL(nextPath, initialPreviewUrl.origin)\n      const preview = url.pathname + url.search\n      if (url.origin === initialPreviewUrl.origin && preview !== params.preview) {\n        navigate({}, {preview})\n      }\n    },\n    [initialPreviewUrl, params, navigate],\n  )\n\n  const handleStructureParams = useCallback(\n    (structureParams: StructureDocumentPaneParams) => {\n      // Omit the prefersLatestPublished param as it causes an internal studio\n      // useEffect to run and replace the revision with the previous value\n      navigate({}, {...structureParams, prefersLatestPublished: undefined})\n    },\n    [navigate],\n  )\n\n  // Dispatch a perspective message when the perspective changes\n  useEffect(() => {\n    channel?.send('overlays', 'presentation/perspective', {\n      perspective: perspective,\n    })\n  }, [channel, perspective])\n\n  // Dispatch a focus or blur message when the id or path change\n  useEffect(() => {\n    if (params.id && params.path) {\n      channel?.send('overlays', 'presentation/focus', {\n        id: params.id,\n        path: params.path,\n      })\n    } else {\n      channel?.send('overlays', 'presentation/blur', undefined)\n    }\n  }, [channel, params.id, params.path])\n\n  // Handle opening the published document when previewing published\n  const latestPublishedIdRef = useRef<string | undefined>(undefined)\n  useEffect(() => {\n    if (\n      perspective === 'published' &&\n      params.id &&\n      params.id !== latestPublishedIdRef.current &&\n      !params.rev &&\n      !params.prefersLatestPublished\n    ) {\n      navigate({}, {prefersLatestPublished: 'true'}, true)\n    }\n    latestPublishedIdRef.current = params.id\n  }, [navigate, params.id, params.prefersLatestPublished, params.rev, perspective])\n\n  // Dispatch a navigation message when the preview param changes\n  useEffect(() => {\n    if (\n      frameStateRef.current.url &&\n      params.preview &&\n      frameStateRef.current.url !== params.preview\n    ) {\n      frameStateRef.current.url = params.preview\n      if (overlaysConnection !== 'connected' && iframeRef.current) {\n        iframeRef.current.src = `${targetOrigin}${params.preview}`\n      } else {\n        channel?.send('overlays', 'presentation/navigate', {\n          url: params.preview,\n          type: 'replace',\n        })\n      }\n    }\n  }, [channel, overlaysConnection, targetOrigin, params.preview])\n\n  const toggleOverlay = useCallback(\n    () => channel?.send('overlays', 'presentation/toggleOverlay', undefined),\n    [channel],\n  )\n\n  const [displayedDocument, setDisplayedDocument] = useState<\n    Partial<SanityDocument> | null | undefined\n  >(null)\n\n  useEffect(() => {\n    const handleKeyUp = (e: KeyboardEvent) => {\n      if (isAltKey(e)) {\n        toggleOverlay()\n      }\n    }\n    const handleKeydown = (e: KeyboardEvent) => {\n      if (isAltKey(e)) {\n        toggleOverlay()\n      }\n\n      if (isHotkey(['mod', '\\\\'], e)) {\n        toggleOverlay()\n      }\n    }\n    window.addEventListener('keydown', handleKeydown)\n    window.addEventListener('keyup', handleKeyUp)\n    return () => {\n      window.removeEventListener('keydown', handleKeydown)\n      window.removeEventListener('keyup', handleKeyUp)\n    }\n  }, [toggleOverlay])\n\n  const [boundaryElement, setBoundaryElement] = useState<HTMLDivElement | null>(null)\n\n  const [{navigatorEnabled, toggleNavigator}, PresentationNavigator] = usePresentationNavigator({\n    unstable_navigator,\n  })\n\n  // Handle edge case where the `&rev=` parameter gets \"stuck\"\n  const idRef = useRef<string | undefined>(params.id)\n  useEffect(() => {\n    if (params.rev && idRef.current && params.id !== idRef.current) {\n      navigate({}, {rev: undefined})\n    }\n    idRef.current = params.id\n  })\n\n  const refreshRef = useRef<number>()\n  const handleRefresh = useCallback(\n    (fallback: () => void) => {\n      dispatch({type: ACTION_IFRAME_REFRESH})\n      if (channel) {\n        // We only wait 300ms for the iframe to ack the refresh request before running the fallback logic\n        refreshRef.current = window.setTimeout(fallback, 300)\n        channel.send('overlays', 'presentation/refresh', {\n          source: 'manual',\n          livePreviewEnabled:\n            previewKitConnection === 'connected' || loadersConnection === 'connected',\n        })\n        return\n      }\n      fallback()\n    },\n    [channel, loadersConnection, previewKitConnection],\n  )\n\n  const workspace = useWorkspace()\n\n  const getCommentIntent = useCallback<CommentIntentGetter>(\n    ({id, type, path}) => {\n      if (frameStateRef.current.url) {\n        return {\n          title: frameStateRef.current.title || frameStateRef.current.url,\n          name: 'edit',\n          params: {\n            id,\n            path,\n            type,\n            inspect: COMMENTS_INSPECTOR_NAME,\n            workspace: workspace.name,\n            mode: EDIT_INTENT_MODE,\n            preview: params.preview,\n          },\n        }\n      }\n      return undefined\n    },\n    [params.preview, workspace.name],\n  )\n\n  const setViewport = useCallback(\n    (next: PresentationViewport) => {\n      // Omit the viewport URL search param if the next viewport state is the\n      // default: 'desktop'\n      const viewport = next === 'desktop' ? undefined : 'mobile'\n      navigate({}, {viewport}, true)\n    },\n    [navigate],\n  )\n\n  const setPerspective = useCallback(\n    (next: PresentationPerspective) => {\n      // Omit the perspective URL search param if the next perspective state is\n      // the default: 'previewDrafts'\n      const perspective = next === 'previewDrafts' ? undefined : next\n      navigate({}, {perspective})\n    },\n    [navigate],\n  )\n\n  return (\n    <>\n      <PresentationProvider\n        devMode={devMode}\n        name={name}\n        navigate={navigate}\n        params={params}\n        searchParams={searchParams}\n        structureParams={structureParams}\n      >\n        <PresentationNavigateProvider navigate={navigate}>\n          <PresentationParamsProvider params={params}>\n            <Container height=\"fill\">\n              <Panels>\n                <PresentationNavigator />\n                <Panel\n                  id=\"preview\"\n                  minWidth={325}\n                  defaultSize={navigatorEnabled ? 50 : 75}\n                  order={3}\n                >\n                  <Flex direction=\"column\" flex={1} height=\"fill\" ref={setBoundaryElement}>\n                    <BoundaryElementProvider element={boundaryElement}>\n                      <PreviewFrame\n                        dispatch={dispatch}\n                        iframe={state.iframe}\n                        initialUrl={initialPreviewUrl}\n                        loadersConnection={loadersConnection}\n                        navigatorEnabled={navigatorEnabled}\n                        onPathChange={handlePreviewPath}\n                        onRefresh={handleRefresh}\n                        openPopup={handleOpenPopup}\n                        overlaysConnection={overlaysConnection}\n                        previewUrl={params.preview}\n                        perspective={perspective}\n                        ref={iframeRef}\n                        setPerspective={setPerspective}\n                        setViewport={setViewport}\n                        targetOrigin={targetOrigin}\n                        toggleNavigator={toggleNavigator}\n                        toggleOverlay={toggleOverlay}\n                        viewport={viewport}\n                        visualEditing={state.visualEditing}\n                      />\n                    </BoundaryElementProvider>\n                  </Flex>\n                </Panel>\n                <PresentationContent\n                  documentId={params.id}\n                  documentsOnPage={documentsOnPage}\n                  documentType={params.type}\n                  getCommentIntent={getCommentIntent}\n                  mainDocumentState={mainDocumentState}\n                  onFocusPath={handleFocusPath}\n                  onStructureParams={handleStructureParams}\n                  searchParams={searchParams}\n                  setDisplayedDocument={setDisplayedDocument}\n                  structureParams={structureParams}\n                />\n              </Panels>\n            </Container>\n          </PresentationParamsProvider>\n        </PresentationNavigateProvider>\n      </PresentationProvider>\n      {channel && (\n        <Suspense>\n          <LoaderQueries\n            channel={channel}\n            liveQueries={liveQueries}\n            perspective={perspective}\n            liveDocument={displayedDocument}\n            documentsOnPage={documentsOnPage}\n          />\n        </Suspense>\n      )}\n      {channel && params.id && params.type && (\n        <Suspense>\n          <PostMessageRefreshMutations\n            channel={channel}\n            id={params.id}\n            type={params.type}\n            loadersConnection={loadersConnection}\n            previewKitConnection={previewKitConnection}\n          />\n        </Suspense>\n      )}\n    </>\n  )\n}\n"],"names":["jsxRuntime","require","csm","ui","react","sanity","router","styledComponents","index","icons","structure","DisplayedDocumentBroadcaster","withoutSecretSearchParams","framerMotion","createSecret","isEqual","pathToRegexp","definePreviewUrl","suspendReact","_interopDefaultCompat","e","default","isEqual__default","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","RESPONSE_TIMEOUT","HEARTBEAT_INTERVAL","HANDSHAKE_INTERVAL","HANDSHAKE_MSG_TYPES","isHandshakeMessage","type","some","t","isLegacyHandshakeMessage","data","Array","isArray","every","key","startsWith","createChannelsControllerInternal","config","target","channels","connectTo","map","buffer","id","handler","handshakeHandler","status","interval","heartbeat","stopHandshake","channel","window","clearInterval","find","from","setChannelStatus","sendHandshake","messageHandler","_a","_b","_c","connectionId","args","onEvent","call","send","responseTo","handleEvents","console","error","origin","domain","to","includes","targetOrigin","isValidMessageEvent","stopHeartbeat","next","onStatusUpdate","uuid","setInterval","startHandshake","heartbeatInverval","startHeartbeat","toFlush","splice","length","forEach","flush","msg","postMessage","expectResponse","maxWait","setTimeout","removeEventListener","transact","warn","eventData","clearTimeout","addEventListener","destroy","store","store2","store3","store4","_stringify","input","Object","getPrototypeOf","constructor","name","_addIssue","context","label","dataset","config2","other","_d","_e","_f","value","expected","expects","received","issue","kind","message","requirement","path","issues","lang","abortEarly","abortPipeEarly","skipPipe","isSchema","reference","get","getSpecificMessage","getGlobalMessage","typed","_isAllowedObjectKey","ValiError","super","__publicField","this","getFallback","schema","fallback","boolean","async","_run","object","entries","value2","valueDataset","pathItem","unshift","optional","wrapped","getDefault","string","parse","getGlobalConfig","y","m","h","w","pipe2","pipe","nextAction","r","o","minLength","s","A","n","a","JSON","stringify","baseUrl","projectId","tool","workspace","isDraft","href","record","entryKey","entryValue","keyDataset","c","unknown","alt","ctrl","mod","test","navigator","platform","shift","debounce","fn","timeout","timer","apply","PanelsContext","createContext","displayName","Root","styled","div","Panel","children","defaultSize","minWidth","maxWidth","order","useContext","getPanelStyle","registerElement","unregisterElement","style","useLayoutEffect","jsx","itemKey","getStoredItem","localStorage","getItem","getKeyForPanels","panels","panel","join","usePanelsStorage","useMemo","set","widths","stored","setItem","setStoredItem","val","setDebounced","getNextWidth","nextWidth","containerWidth","maxWidthPx","minWidthPx","Math","min","max","getPanelWidth","width","findIndex","toPrecision","getOffset","event","handleElement","initialOffset","initialHandleElementRect","clientX","getBoundingClientRect","left","isPanel","element","isResizer","getSortedElements","elements","values","sort","b","validateWidths","widthsToValidate","total","reduce","remainingWidth","toFixed","abs","PanelsWrapper","Panels","panelsEl","useRef","setElements","useState","Map","filter","setWidths","activeResizer","setActiveResizer","panelsRef","useCallback","flexGrow","pointerEvents","prev","has","delete","dragRef","innerWidth","dragOffset","panelAfter","panelBefore","resizerIndex","resizerRect","startX","startDragging","elementsArr","el","resizer","resizeElement","current","acc","pageX","stopDragging","drag","preventDefault","stopPropagation","prevWidths","nextWidths","delta","panelsState","initialDragState","initialWidths","pivotPanel","deltaApplied","localeCompare","numeric","getNextWidths","prevWidth","storage","storedWidths","validatedStoredWidths","defaultWidths","panelsWithoutWidth","remainingWidthTotal","widthsWithNulls","defaultWidth","getDefaultWidths","useEffect","resizeObserver","ResizeObserver","observe","disconnect","Provider","ref","ErrorCard","props","onRetry","onContinueAnyway","restProps","useTranslation","presentationLocaleNamespace","retryButton","Button","fontSize","mode","onClick","text","continueAnywayButton","tone","Card","height","Flex","align","justify","Container","padding","sizing","jsxs","Stack","space","Text","size","weight","muted","Inline","Box","resolveQueryStringFromParams","nextParams","allowed","params","parts","encodeQueryString","obj","BackLink","forwardRef","searchParams","StateLink","state","_searchParams","title","ReferenceChildLink","documentId","documentType","parentRefPath","template","prefersLatestPublished","perspective","PresentationPaneRouterProvider","onStructureParams","structureParams","refs","routerState","resolvePathFromState","useRouter","routerSearchParams","useUnique","fromEntries","createPathWithParams","groupIndex","siblingIndex","payload","hasGroupSiblings","groupLength","routerPanesState","ChildLink","childLinkProps","childId","_id","getPublishedId","_type","backLinkProps","ParameterizedLink","Fragment","closeCurrentAndAfter","handleEditReference","replaceCurrent","pane","closeCurrent","duplicateCurrent","setView","viewId","setParams","inspect","setPayload","navigateIntent","intentName","intentParams","PaneRouterContext","RootLayout","PaneLayout","WrappedCode","Code","DocumentListPane","mainDocumentState","p","devMode","usePresentationTool","u","ids","document","schemaTypeName","errorParams","setErrorParams","handleRetry","flex","overflow","radius","Label","ErrorBoundary","onCatch","StructureToolProvider","direction","StructureDocumentListPane","itemId","paneKey","DocumentPane","onFocusPath","templateParams","paneDocumentNode","templateParameters","decodeJsonParams","StructureDocumentPane","DocumentPanel","ContentEditor","useSchema","MainDocumentLink","schemaType","previewState","documentPreviewStore","useDocumentPreviewStore","preview","setPreview","subscription","getPreviewStateObservable","subscribe","unsubscribe","usePreviewState","SanityDefaultPreview","getPreviewValueWithFallback","published","draft","shadow","PreviewCard","__unstable_focusRing","as","gap","WarningOutlineIcon","Translate","i18nKey","components","Resizer","ResizerInner","$disabled","PanelResizer","propId","disabled","usePanelId","isDragging","onMouseDown","nativeEvent","onDrag","onDragStop","blur","resetDocumentStyles","bodyStyle","body","documentStyle","documentElement","cursor","userSelect","removeProperty","setDocumentStyles","PresentationContentWrapper","setDisplayedDocument","getCommentIntent","DisplayedDocumentBroadcasterProvider","D","CommentsIntentProvider","getIntent","PresentationContent","documentsOnPage","PresentationNavigateProvider","navigate","_navigate","PresentationNavigateContext","usePresentationNavigator","unstable_navigator","navigatorProvided","component","_navigatorEnabled","setNavigatorEnabled","defaultValue","setValue","useLocalState","navigatorEnabled","toggleNavigator","enabled","Component","Navigator","memo","NavigatorComponent","navigatorDisabled","PresentationParamsProvider","PresentationParamsContext","PresentationProvider","PresentationContext","ACTION_IFRAME_LOADED","ACTION_IFRAME_REFRESH","ACTION_IFRAME_RELOAD","ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE","presentationReducer","action","iframe","toggleVisualEditingOverlays","visualEditing","overlaysEnabled","mainDocumentSchema","fallback2","iframeStatusSchema","picklist","initStateSchema","mainDocument","INITIAL_PRESENTATION_STATE","presentationReducerInit","IFrameElement","motion","IFrameOverlay","IFrame","animate","initial","onLoad","preventClick","src","variants","PreviewLocationInput","onChange","prefix","suffix","basePath","useActiveWorkspace","activeWorkspace","inputRef","sessionValue","setSessionValue","customValidity","setCustomValidity","handleChange","currentTarget","handleKeyDown","absoluteValue","nextValue","handleBlur","resetButton","icon","ResetIcon","TextInput","clearButton","onBlur","onClear","onKeyDownCapture","zIndex","ShareUrlMenuItems","initialUrl","openPopup","previewLocationOrigin","previewLocationRoute","handleOpenPopup","CopyUrlMenuButton","MenuItem","LaunchIcon","rel","pushToast","useToast","client","useClient","apiVersion","API_VERSION","currentUser","useCurrentUser","setDisabled","clipboard","closable","url","onFinally","onError","description","hasSecretSearchParams","resolvePreviewUrl","previewUrlSecret","createPreviewSecret","location","setSecretSearchParams","secret","ClipboardItem","item","then","Blob","write","catch","writeText","CopyIcon","MotionFlex","PERSPECTIVE_TITLE_KEY","previewDrafts","PERSPECTIVE_TONES","PERSPECTIVE_ICONS","EditIcon","PublishIcon","PreviewFrame","dispatch","loadersConnection","onPathChange","onRefresh","overlaysConnection","previewUrl","setPerspective","setViewport","toggleOverlay","viewport","prefersReducedMotion","usePrefersReducedMotion","toggleViewportSize","loading","timedOut","setTimedOut","refreshing","somethingIsWrong","setSomethingIsWrong","iframeIsBusy","handleRefresh","handleContinueAnyway","setContinueAnyway","continueAnyway","showOverlaysConnectionStatus","setShowOverlaysConnectionState","MAX_TIME_TO_OVERLAYS_CONNECTION","M","previewURL","URL","pathname","search","onIFrameLoad","instance","activeElement","dispatchEvent","MouseEvent","bubbles","cancelable","preventIframeInteraction","iframeAnimations","MotionConfig","transition","duration","TooltipDelayGroupProvider","delay","position","minHeight","marginRight","Tooltip","content","fallbackPlacements","placement","portal","PanelLeftIcon","selected","whiteSpace","paddingY","Hotkeys","keys","marginTop","marginBottom","lineHeight","borderRadius","margin","Switch","checked","marginX","RefreshIcon","MenuButton","button","iconRight","ShareIcon","menu","Menu","popover","constrainSize","ChevronDownIcon","pressed","createElement","opacity","CheckmarkIcon","MobileDeviceIcon","DesktopIcon","AnimatePresence","exit","spinnerVariants","inset","sizes","Spinner","errorVariants","background","borderTop","boxShadow","backdropFilter","WebkitBackdropFilter","WebkitTransition","iframeVariants","desktop","mobile","scale","idle","reloading","active","warnedAboutCrossDatasetReference","fnOrObj","arg","Function","getRouteContext","route","routes","absolute","result","match","decode","decodeURIComponent","useMainDocument","navigationHistory","resolvers","setMainDocumentState","mainDocumentIdRef","relativeUrl","base","clearState","resolver","query","resolve","getQueryFromResult","controller","AbortController","signal","fetch","doc","at","abort","parseId","rawId","segments","split","parsePath","rawPath","studioPath","exec","e2","Number","_key","urlStringToPath","pruneObject","useParams","initialPreviewUrl","routerNavigate","frameStateRef","rev","since","view","pathKey","instruction","comment","routerStateRef","setNavigationHistory","nextState","nextSearchState","forceReplace","routerSearchState","searchState","replace","usePreviewUrl","toolName","previewSearchParam","workspaceName","deps","cachedPreviewSearchParam","setCachedPreviewSearchParam","timeoutRef","resolveUUID","useSuspendCacheKeys","secretLastExpiredAt","setSecretLastExpiredAt","suspend","startTransition","expiresAt","getTime","Date","now","usePreviewUrlSecret","resolvedUrl","resultUrl","restoredUrl","referrer","referrerUrl","studioBasePath","Symbol","LoaderQueries","lazy","Promise","PostMessageRefreshMutations","exports","_previewUrl","DEFAULT_TOOL_NAME","option","hostname","iframeRef","setChannel","liveQueries","setLiveQueries","useReducer","setDocumentsOnPage","setPublished","setPreviewDrafts","urlRef","sourceDocuments","documents","sourceDocument","_projectId","cache","uniqueDocuments","useDocumentsOnPage","useProjectId","useDataset","mainDocuments","setOverlaysConnection","setLoadersConnection","previewKitConnection","setPreviewKitConnection","popups","Set","source","open","add","closed","addSource","perspectiveRef","contentWindow","nextChannel","sources","sendToSource","WeakMap","destroySource","prevConnectTo","createChannelsController","refreshRef","MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL","getQueryCacheKey","receivedAt","liveQuery","handleFocusPath","nextPath","handlePreviewPath","handleStructureParams","latestPublishedIdRef","displayedDocument","handleKeyUp","handleKeydown","toUpperCase","boundaryElement","setBoundaryElement","PresentationNavigator","idRef","livePreviewEnabled","useWorkspace","COMMENTS_INSPECTOR_NAME","C","EDIT_INTENT_MODE","E","BoundaryElementProvider","Suspense","liveDocument"],"mappings":"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","x_google_ignoreList":[0,1,2,3,7]}